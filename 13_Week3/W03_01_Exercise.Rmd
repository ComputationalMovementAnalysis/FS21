# Exercise 3
<!-- Stops and moves -->
<!-- Trajectory segmentation -->
<!-- Similarity measures and clustering -->

## Learning Outcomes
+ You are able to segment a trajectory using @laube2011
+ You are able to compute the similarity between given trajectories using the package `SimilarityMeasures.`
+ You acquire further useful data processing skills.
<!-- Todo: passt das noch? -->

## Prerequisites
Readings Skills from "R for Data Science" [@wickham2017]:

+ RS3.1 Chap1 Data visualization with `ggplot2` (31, 3-35)
+ RS3.2 Chap5 Exploratory Data Analysis (28p, 81.109)

Readings Theory:

@both2018 A Comparative Analysis of Trajectory Similarity Measures: Recommendations for Selection and Use, in review with PLOS ONE, confidential.
<!-- ToDO: get update on the package similarity measures -->

## Preperation

```{r}
library(tidyverse)
library(plotly)
library(CMAtools)
library(recurse)
```


## Tasks

### Input: `cut()` vector by intervals

<!-- TODO: kommt noch von E2, anpassen auf E3 -->

For the next Task, we will need a function to split a continuous variable into specific intervals. For this, the function `cut()`is very handy. Let's introduce this function with a quick example. Assume we have a series of number that represent the ages of ten different people.

```{r}
## Input: cut vecotrs by intervals ####################
```


```{r, echo = T, eval = T, include = T}
ages <- c(20,25,18,13,53,50,23,43,68,40)
```
Let's say we want to split this into equal intervals of 10 years.

```{r, echo = T, eval = T, include = T}
breaks <- seq(0,50,10)

cut(ages,breaks = breaks)
```
Note:

- If a number does not fit within an interval defined by `breaks =`, `cut()` will return `NA` (as for example for the fifth element `53`).
- The default `labels` with `(` and `]` might seem a little ugly and puzzling at first, but in fact they are [a standard form of notating intervals in mathematics](https://en.wikipedia.org/wiki/Interval_%28mathematics%29#Notations_for_intervals).
- If you don't like `(` and `]`, you can:
  + specify your own labels with the argument `labels =` *or*
  + use the the function `labels_nice` we provide with the `CMAtools`-package
- Four thresholds (i.e. `breaks`) return three intervals (i.e. `lables`), as shown below.

```{r, echo = T, eval = T, include = T}

library(CMAtools)

breaks <- c(0,30,60,100)

cut(ages, breaks = breaks, labels = c("young","middle aged","old"))

cut(ages, breaks = breaks, labels = labels_nice(breaks))


```



### Task 2: Making groups by sampling Interval

<!-- TODO: kommt noch von E2, anpassen auf E3 -->

Now that we've established that we have different sampling intervals (Task 1), we have to segment our trajectories in such a way, that we can perform further analysis during specific sampling intervals only. If we measure speed, or turning angles, we have to be very clear on what temporal (an thus spatial) scale or granularity we are performing this analysis. 

We therefore have to define thresholds to group segments with a similar sampling interval. Explore the dataset in more detail (e.g. using histograms at different scales), and choose reasonable threshold values to group the trajectories into different sampling intervals. 

Note: 

- It might make more sense to choose narrow intervals at shorter time lags and wider intervals at longer time lags.
- Store the interval names in a new column named `samplingInt`
- explore the dataset by using a logarithmic `y-axis` (`scale_y_log10()`) and looking at the different parts of the `x-axis` seperately
- We will later filter the data by the sampling interval. We therefore recommend the use of `labels_nice()` from the package `CMAtools` for nicer, more intuitive labels.


```{r, echo = F, include = T, eval = T}
## Task 2 ####################

breaks <- c(0,40,80,300,600,1200,2500,3000,4000,7500,110000)


ggplot(wildschwein_BE, aes(timelag)) +
  geom_histogram(binwidth = 10) +
  lims(x = c(0,600)) +
  scale_y_log10() +
  geom_vline(xintercept = breaks, col = "red")

ggplot(wildschwein_BE, aes(timelag)) +
  geom_histogram(binwidth = 10) +
  lims(x = c(600,1200)) +
  scale_y_log10() +
  geom_vline(xintercept = breaks, col = "red")


ggplot(wildschwein_BE, aes(timelag)) +
  geom_histogram(binwidth = 10) +
  lims(x = c(1200,10000)) +
  scale_y_log10() +
  geom_vline(xintercept = breaks, col = "red")


wildschwein_BE <- wildschwein_BE %>%
  group_by(TierID) %>%
  mutate(
    samplingInt = cut(timelag,breaks = breaks,labels = labels_nice(breaks))
  ) 

# wildschwein_BE %>%
#   as.data.frame() %>%
#   group_by(samplingInt) %>%
#   summarise(
#     n = n()
#   ) %>%
#   ggplot(aes(samplingInt,n)) +
#   geom_bar(stat = "identity") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   scale_y_log10()

# Todo: diesen Plot entfernen?
```


### Task 1: Segmenting methods

```{r}
## Task 1 ####################
```


You've read @laube2011 about segmenting trajectories. In the paper, they define "*static*" fixes as "*those whose average Euclidean distance to other fixes inside a temporal window *v* is less than some threshold *d**". This sounds more complicated than it is, the figure illustrates the method nicely.

![](02_Images/laube_2011.jpg)

Try to implement this method on some dummy data. Once you've solved the problem on this simple data, we will implement it on the wild boar data next week. 

```{r, include = T, purl = F}
set.seed(10)
X = cumsum(rnorm(20))
Y = cumsum(rnorm(20))

plot(X,Y, type = "l")
```

Assume the sampling interval is 5 minutes. If we take a temporal window of 20 minutes, that would mean we include 5 fixes into the calculation. We need to calculate the following Euclidean distances (pos representing a `X`,`Y`-position):

1. pos[n-2] to pos[n]
2. pos[n-1] to pos[n]
3. pos[n] to pos[n+1]
4. pos[n] to pos[n+2]

You can use the function `euclid()` to calculate the distances and `dplyr` functions `lead()/``lag()` to create the necessary offsets. On our dummy data, we want to calculate the mean of the following distances (red, dotted lines).

```{r, purl = F, echo = F, include = T}
library(ggrepel)

df <- data.frame(X = X, Y = Y)

df <- df %>%
  mutate(
    Xm2 = lag(X,2),
    Ym2 = lag(Y,2),
    Xm1 = lag(X,1),
    Ym1 = lag(Y,1),    
    Xp1 = lead(X,1),
    Yp1 = lead(Y,1),    
    Xp2 = lead(X,2),
    Yp2 = lead(Y,2)
  )

n = 6
ggplot(df, aes(X,Y)) +
  geom_path() +
    geom_segment(data = df[n,], aes(x = Xm2,y = Ym2,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash",lwd = 1, colour = "red", inherit.aes = FALSE )+
    geom_segment(data = df[n,], aes(x = Xm1,y = Ym1,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash", lwd = 1, colour = "red", inherit.aes = FALSE )+
    geom_segment(data = df[n,], aes(x = Xp1,y = Yp1,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash", lwd = 1, colour = "red", inherit.aes = FALSE )+
    geom_segment(data = df[n,], aes(x = Xp2,y = Yp2,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash", lwd = 1, colour = "red", inherit.aes = FALSE ) +
  # coord_fixed(1) +
  geom_label_repel(data = df[n,], aes(x = X, y = Y),label = "pos n", nudge_x = 1) +
  geom_label_repel(data = df[n,], aes(x = Xp1, y = Yp1),label = "pos n+1",nudge_x = -1) +
  geom_label_repel(data = df[n,], aes(x = Xp2, y = Yp2),label = "pos n+2") +
  geom_label_repel(data = df[n,], aes(x = Xm2, y = Ym2),label = "pos n-2",nudge_y = 1) +
  geom_label_repel(data = df[n,], aes(x = Xm1, y = Ym1),label = "pos n-1") +
  theme_classic() +
  theme_classic(base_size = 16)


```

```{r}

nMinus2 <- euclid(lag(X, 2),lag(Y, 2),X,Y)  # distance to pos. -10 minutes
nMinus1 <- euclid(lag(X, 1),lag(Y, 1),X,Y)  # distance to pos.  -5 minutes
nPlus1  <- euclid(X,Y,lead(X, 1),lead(Y, 1)) # distance to pos   +5 mintues
nPlus2  <- euclid(X,Y,lead(X, 2),lead(Y, 2)) # distance to pos  +10 minutes

# Use cbind to bind all rows to a matrix
distances <- cbind(nMinus2,nMinus1,nPlus1,nPlus2)
distances

# This just gives us the overall mean
mean(distances, na.rm = T)

# We therefore need the function `rowMeans()`
rowmeans <- rowMeans(distances)
cbind(distances,rowmeans)

# and if we put it all together:
rowMeans(
  cbind(
    euclid(lag(X, 2),lag(Y, 2),X,Y),
    euclid(lag(X, 1),lag(Y, 1),X,Y),  
    euclid(X,Y,lead(X, 1),lead(Y, 1)), 
    euclid(X,Y,lead(X, 2),lead(Y, 2))
  )
)
```

### Task 2

Picking up from the previous task: we can now implement this algorithm using the `dplyr` / `mutate()` method. This might seem a little challenging at first, but if you have completed Task 4 or at least looked at the sample solution, it is quite easy. You can pass anything to a new column within `mutate()` as long as it is a vector of the same length as the original dataframe. 

```{r}

## Task 2 ####################

wildschwein_BE_sf <- wildschwein_BE_sf %>%
  group_by(TierID) %>%
  mutate(
    stepMean = rowMeans(
      cbind(
        euclid(lag(E, 2),lag(N, 2),E,N),
        euclid(lag(E, 1),lag(N, 1),E,N),
        euclid(E,N,lead(E, 1),lead(N, 1)),
        euclid(E,N,lead(E, 2),lead(N, 2))
        )
      )
  )
```


### Task 3

We can now explore the newly created Values `stepMean` using summary statistics (histograms, boxplot, `summary()`) and define a reasonable threshold value to differentiate between "stops" and "moves". There is no "correct" way of doing this, specifying a threshold always depends on the question that needs to be answered. 

```{r, echo = F, include = T}
## Task 3 ####################


summary(wildschwein_BE_sf$stepMean)

ggplot(wildschwein_BE_sf, aes(stepMean)) +
  geom_histogram(binwidth = 1) +
  lims(x = c(0,100)) +
  geom_vline(xintercept = 15)

```


Based on this data, I will go with a threshold value of 15. Apply your threshold on you data (condition: `stepMean > 15`).

```{r}

wildschwein_BE_sf <- wildschwein_BE_sf %>%
  mutate(
    moving = stepMean > 15
  )

```

Plot a *subset* of data to verify if the arbitrary threshold was a reasonable choice. 

- sub-setting the first ten rows can be done with `[1:10,]` (don't forget the comma!)
- we have a couple of NA values in the beginning and end of each trajectory. Use `filter(!is.na(moving))` to remove these values from the plot
- if you add the layer `geom_sf()` `ggplot` will only plot points. To add the lines in between you'll have to specify the x and y values (E and N)
- add the layer `coord_sf(datum = 2056)`
- wrap the whole plot function in `ggplotly()` if you want to enable zooming / panning

```{r, echo = F, include = T}
wildschwein_BE_sf[20:50,] %>%
  filter(!is.na(moving)) %>%
  ggplot() +
  geom_sf(aes(colour = moving)) +
  geom_path(aes(E,N)) +
  coord_sf(datum = 2056) +
  theme(
    panel.grid.major = element_line(colour = "transparent"),
    panel.background = element_rect(fill = "transparent")
    ) 

```


### Input

<!-- TODO: dieser Input und der nÃ¤chste Task sind Copy+Paste aus der letzten Woche. Die noch richtig anpassen -->

For the next task, it would be pretty handy if each sequence of positions with the *same* sampling interval had a unique ID. In this way, we could use this ID to filter the dataset for uninterrupted, "clean", trajectories without varying sampling intervals and could also use the ID as a grouping variable. 

This type of "grouping" similar values is a pretty common task that we often come across. So far, we've not found a good solution from available packages. We have therefore created our own function that we provide with the `CMAtools` package called `number_groups()`. This function takes a logical vector as an input and assigns subsequent `TRUE` values to the same group. Consider following example:

```{r}
sample <- data.frame(position = paste0("pos",1:6),samplingInt=c(rep(60,3),rep(120,3)))
```

```{r, echo=T, include=T,eval=T}
sample
```

In this example, the first three positions belong to one group and the next three belong to a second group. `number_groups()` takes a logical vector which answers the following question for each value `i`: "Does the next value (`i+1`) belong to the same group as *this* value `i`?". We first have to provide the answer to this question by using `lead()` again:


```{r, echo = T, include = T,eval = T}
sample <- sample %>%
  mutate(
    samplingInt_control = samplingInt == lead(samplingInt,1),
    samplingInt_group = number_groups(samplingInt_control,include_first_false = T)
  )

sample
```

Use `?number_groups` to get more information.

### Task 4

Use the function `number_groups()` (or any other method) to assign unique ID's to subsequent rows of the *same* sampling interval (`samplingInt`). Make sure unique ID's are not assigned *across* different individuals.

```{r}
wildschwein_BE <- wildschwein_BE %>%
  group_by(TierID) %>%
  mutate(
    samplingInt_T = samplingInt == lead(samplingInt),
    group = number_groups(samplingInt_T,include_first_false = T)
  ) %>%
  dplyr::select(-samplingInt_T)
```

<!-- TODO: see what the warnings are for. also update function doc -->



### Task 4 (Optional)

To be honest, exploring segmentation with `ggplot` (and even `plotly`) is not very satisfying. Another great tool to visualize spatial data is leaflet. It's not all that hard to create a leaflet plot, just take a look at the documentation and try it with our segmented wild boar data. 

```{r, purl = F, echo = F, include = T}

## Task 4 ############################

if (knitr::is_html_output()){
  library(leaflet)
  library(scales)
  factpal <- colorFactor(hue_pal()(2), wildschwein_BE_sf$moving)

# checking to see if this all makes sense in leaflet: (or better ggplot?)
  wildschwein_BE_sf[0:200,] %>%
    filter(!is.na(moving)) %>%
    leaflet() %>%
    addCircles(radius = 1,lng = ~Long, lat = ~Lat, color = ~factpal(moving)) %>%
    addPolylines(opacity = 0.1,lng = ~Long, lat = ~Lat) %>%
    addTiles() %>%
    addLegend(pal = factpal, values = ~moving, title = "Animal moving?")
} else{"map only available in the online version of this document"}
```


```{r, eval=F}
# library(leaflet)
# library(scales)
# factpal <- colorFactor(hue_pal()(2), wildschwein_BE_sf$moving)
# 
# # checking to see if this all makes sense in leaflet: (or better ggplot?)
# wildschwein_BE_sf[0:200,] %>%
#   filter(!is.na(moving)) %>%
#   leaflet() %>%
#   addCircles(radius = 1,lng = ~Long, lat = ~Lat, color = ~factpal(moving)) %>%
#   addPolylines(opacity = 0.1,lng = ~Long, lat = ~Lat) %>%
#   addTiles() %>%
#   addLegend(pal = factpal, values = ~moving, title = "Animal moving?")
```


### Task 5

Use the package `recurse` (function `getRecursions`) to determine sites which are often visited. 
<!-- Todo: either extend this task or use this as a possible challange for the individual topics and replace this with similarity measures  -->


```{r,, echo = F, include = T}

## Task 5 #######################

library(recurse)
library(ggforce)

recurs <- wildschwein_BE_sf %>% 
  filter(TierID == "001A") %>%
  select(E,N,DatetimeUTC,TierID) %>%
  st_set_geometry(NULL) %>%
  as.data.frame() %>%
  getRecursions(100)

recurStats <- recurs$revisitStats

recurStats <- recurStats %>%
  group_by(coordIdx) %>%
  summarise(
    number_of_visits = max(visitIdx),
    x = unique(x),
    y = unique(y),
    total_time = sum(timeInside),
    max_time = max(timeInside),
    mean_time = mean(timeInside)
  )

data1 = filter(recurStats, number_of_visits > 30)
wildschwein_BE_sf %>%
  ungroup() %>%
  filter(TierID == "001A") %>%
  ggplot(aes(E,N)) +
  geom_point(alpha = 0.4, colour = "grey") +
  geom_circle(data = data1, alpha = 0.5, aes(x0 = x,y0 = y,fill = mean_time,r = 100),inherit.aes = F) +
  coord_fixed(1)

```



## Solution (R Code)

```{r code=readLines('13_Week3/RFiles/W03_01_Exercise.R'), results='asis', echo = T, include=T, eval=F}
```