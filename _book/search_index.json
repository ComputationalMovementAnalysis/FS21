[
["index.html", "Patterns and Trends in Environmental Data Master ENR, Spring Semester 2020 Introduction Chapter", " Patterns and Trends in Environmental Data Master ENR, Spring Semester 2020 Patrick Laube and Nils Ratnaweera 11 February, 2020 Introduction Chapter For our practical R course building-up skills for analyzing movement data in the software environment R, you’ll be using data from the ZHAW project “Prävention von Wildschweinschäden in der Landwirtschaft”. The project investigates the spatiotemporal movement patterns of wild boar (Sus scrofa) in agricultural landscapes. We will study the trajectories of these wild boar, practicing the most basic analysis tasks of Computational Movement Analysis (CMA). Please note: we are given application data from an ongoing research project. Capturing wild living animals and then equipping them with GPS collars is a very labor and cost intensive form of research. Consequently, data resulting such campaigns is a very valuable asset that must be protected. So, please do not pass on this data, for any use beyond this module contact Patrick Laube or the data owner Stefan Suter (suts@zhaw.ch). "],
["exercise-1.html", "Exercise 1 Leaning outcomes Prerequisites Preperation Tasks and inputs", " Exercise 1 Exercise 1 covers the necessary steps for getting ready in R and some basic concepts for setting up a well-structured R project. The lesson introduces how additional packages that provide useful functions for data science are made available and how spatial data is handled. The exercise concludes with the creation of your first map featuring movement data. Leaning outcomes You learn how to structure an R project. You can read movement data from a .csv-file into a data.frame You can convert spatial point data from a data.frame to a spatial object sf You can perform basic spatial operations on spatial objects in R You can produce simple maps of your spatial data using ggplot2 You can produce simple maps of your spatial data using tmap Prerequisites Readings Skills from “R for Data Science” (Wickham and Grolemund 2017): RS1.1 Preface (16p, ix-xxiv) RS1.2 Chap2 Workflow basics (3p, 37-39) RS1.3 Chap4 Workflow scripts (3p, 77-79) RS1.4 Chap6 workflow projects (6p, 111-116) RS1.5 Chap8 Data Import with readr (21p) RS1.6 Chap13 Date and Times with lubridate (18p, 237-256) Preperation If you haven’t already, install the packages tidyverse, and devtools (using install.packages()). Additionally, install the packages sf, raster and ggspatial. Restart your R session after installing all these packages. install.packages(&quot;tidyverse&quot;) install.packages(&quot;sf&quot;) install.packages(&quot;raster&quot;) Tasks and inputs Task 1: Initialize project Create a new RStudio Project. As recommended in Wickham and Grolemund (2017), remove the option “Restore .RData into workspace at startup” and set the option “save workspace to .RData on exit” to “Never”. Create a new .R (or .Rmd) File and divide it into the sections necessary in a classical Data Science Workflow. In .R Files, “Sections” can be created within RStudio by adding Comments (#) with at least 4 trailing dashes, equal, or pound signs ( -, =,#). In .Rmd Files, their are created with leading pound signs (#). Sections allow code folding (try clicking on the small triangle next to the line number) and facilitate navigation (try the shortcut: Shift+Alt+J). We recommend following sections: Loading environment / libraries Data import Data cleansing Data analysis and visualization Task 2: Import data In section “data import”, import the file wildschwein_BE.csv. Obtain this file from moodle. Note: If your are using a graphical tool to import your code, make sure you save the corresponding code in your R Script. This is important in regard to the reproducibility of your script and will ensure that your workflow is documented without gaps. We’d rather recommend to move away from using graphical tools and focus on using code. We recommend using one of the tidyverse functions from the readr package to import your data (they all begin with &quot;read_*, note the underscore). These functions are less error prone than the base R functions (read.*). Specifically for the wild boar data, we recommend read_delim(). If you use read_delim() and receive warnings during import, have a look at these warnings by using the function problems(). Resolve these problems until import runs without warnings. Assign correct data types as necessary and make sure the time zone is set correctly for the date/time column. For everyone working on the RStudio Server: You will first need to upload this data to the server using the “upload”-button in the “Files” tab. Task 3: Explore Data We will use a range of different visualization tools (i.e. R-packages) in this course. Several packages techniques have emerged in recent years, each with their specific strengths and weaknesses. While base::plot()is quick and simple, it not very scalable with growing complexity. ggplot2 offers solutions for most use cases and has an elegant, consistent syntax that is easy to get accustomed to. We will get to know other techniques later in the course. Get an overview of your data by creating a first “map-like” plot of your data producing a simple scatter plot with ggplot2. Setting up a ggplot with our data is done using the command ggplot(wildschwein_BE, aes(Long, Lat, colour = TierID)). Creating a map is done via the basic scatter plot command geom_point(). Assigning every individual its own colour is done using the ggplot argument colour =. Save your code in the appropriate section. Input: Handling spatial data Until now, we’ve stored our location data within data frames as Lat/Long columns. This works well for many tasks, but sometimes we need special spatial classes to handle our trajectories. We will get to know such cases in our next tasks, but first we need to convert our data.frame into a spatial object. Some of you might be familiar with the sp package with the classes SpatialPoints, SpatialPointsDataFrame and so on. These packages are mostly replaced by the fairly new package sf. This packages has some huge advantages over sp: simple features are essentially data frames with minor extensions and thus are easily integratable in standard workflows they are programmed to cleanly interface with the tidyverse methods (specifically dplyr’s mutate and summarise) comply with the common Open Geospatial Consortium (OGC) standards (ISO 19125-1:2004) and interface with other important spatial tools such as GDAL, PostGIS, GeoJSON and so fourth are being rapidly implemented in visualisation tools such as ggplot2, plotly and tmap We will largely rely on sfwhen working with vector data in R. In order to transform our data.frame into an sf object, we need to use the function st_as_sf() while specifying the columns storing the coordinates and the coordinate reference system1. library(sf) wildschwein_BE_sf &lt;- st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) Notice how st_as_sf takes the EPSG code for the crs = argument. This is so much easier and more elegant than using PROJ.4 or WKT. You can find a lot of useful information on Coordinate Reference Systems (including EPSG Codes , etc.) under spatialreference.org or http://epsg.io. Let’s compare our original data.frame with this new sf object: wildschwein_BE ## # A tibble: 51,246 x 6 ## TierID TierName CollarID DatetimeUTC Lat Long ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 47.0 7.05 ## 2 002A Sabi 12275 2014-08-22 21:15:16 47.0 7.05 ## 3 002A Sabi 12275 2014-08-22 21:30:43 47.0 7.05 ## 4 002A Sabi 12275 2014-08-22 21:46:07 47.0 7.05 ## 5 002A Sabi 12275 2014-08-22 22:00:22 47.0 7.05 ## 6 002A Sabi 12275 2014-08-22 22:15:10 47.0 7.05 ## 7 002A Sabi 12275 2014-08-22 22:30:13 47.0 7.05 ## 8 002A Sabi 12275 2014-08-22 22:45:11 47.0 7.05 ## 9 002A Sabi 12275 2014-08-22 23:00:27 47.0 7.05 ## 10 002A Sabi 12275 2014-08-22 23:15:41 47.0 7.05 ## # … with 51,236 more rows wildschwein_BE_sf ## Simple feature collection with 51246 features and 4 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 7.019889 ymin: 46.97125 xmax: 7.112075 ymax: 47.01882 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## # A tibble: 51,246 x 5 ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [°]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (7.049618 46.99317) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (7.049509 46.99416) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (7.049406 46.99383) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (7.049217 46.99375) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (7.049359 46.99375) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (7.049363 46.99382) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (7.049326 46.99387) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (7.049237 46.99395) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (7.048383 46.99481) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (7.049396 46.99373) ## # … with 51,236 more rows As you can see, st_as_sf() has added some metadata to our dataframe (geometry type, dimension, bbox, epsg and proj4string) and replaced the columns Lat and Long with a column named geometry. Other than that, the new sf object is very similar to our original dataframe. In fact, sf objects are essentially dataframes, just ask R: is.data.frame(wildschwein_BE_sf) ## [1] TRUE All operations we know from handling data.frames can be used on the sf object. Try some out! # subset rows wildschwein_BE_sf[1:10,] wildschwein_BE_sf[wildschwein_BE_sf$TierName == &quot;Sabi&quot;,] # subset colums wildschwein_BE_sf[,2:3] Instead of keeping the same data twice (once as a data.frame, and once as an sf object), we will overwrite the data.frame and continue working with the sf object from now on. This saves some memory space in R and avoids confusion. wildschwein_BE = st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) rm(wildschwein_BE_sf) # we can remove this sf object, since it just eats up our memory Task 4: Project data from WGS84 So what can we do with our new sf object that we couldn’t before? One example is projecting the WGS84 (Lat/Long) coordinates into the new Swiss CRS CH1903+ LV952. Do this by using the function st_transform. By the way, do you notice a pattern here? The package sf names most functions for spatial operations with the prefix st_*, just as in PostGIS. Here’s the resulting sf object from the operation: ## Simple feature collection with 51246 features and 4 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 51,246 x 5 ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [m]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (2570409 1204752) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (2570402 1204863) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (2570394 1204826) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (2570379 1204817) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (2570390 1204818) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (2570390 1204825) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (2570387 1204831) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (2570381 1204840) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (2570316 1204935) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (2570393 1204815) ## # … with 51,236 more rows Input: Calculate Convex Hull Transforming from one Coordinate Reference System to another was one operation where we needed an object with a spatial nature. In this way, we were able to use an off the shelf function to project the coordinates from one CRS to another. In our next example, we again rely on a spatial function: We want to calculate a convex hull per Wild boar. And guess what the function for calculating a convex hull is called in sf? If you guessed st_convex_hull(), you were right! By default st_convex_hull() calculates the convex hull per feature, i.e. per point in our dataset. This of course makes little sense. In order to calculate the convex hull per animal, we need to convert our point- to multipoint-features where each feature contains all positions of one animal. This is achieved in two steps: First: add a grouping variable to the sf object. Note the new grouping variable in the metadata of the sf object. Other than that, group_by has no effect on our sf object. wildschwein_BE_grouped &lt;- group_by(wildschwein_BE,TierID) wildschwein_BE_grouped ## Simple feature collection with 51246 features and 4 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 51,246 x 5 ## # Groups: TierID [3] ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [m]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (2570409 1204752) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (2570402 1204863) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (2570394 1204826) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (2570379 1204817) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (2570390 1204818) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (2570390 1204825) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (2570387 1204831) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (2570381 1204840) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (2570316 1204935) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (2570393 1204815) ## # … with 51,236 more rows Second: use summarise() to “dissolve” all points into a mulipoint object. wildschwein_BE_smry &lt;- summarise(wildschwein_BE_grouped) wildschwein_BE_smry ## Simple feature collection with 3 features and 1 field ## geometry type: MULTIPOINT ## dimension: XY ## bbox: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 3 x 2 ## TierID geometry ## * &lt;chr&gt; &lt;MULTIPOINT [m]&gt; ## 1 002A (2568903 1206200, 2568925 1206207, 2568980 1206197, 2569024 12063… ## 2 016A (2569231 1205823, 2569245 1205925, 2569247 1206027, 2569251 12058… ## 3 018A (2568153 1205611, 2568155 1205613, 2568161 1205624, 2568162 12056… Now we can run st_convex_hull on the new sf object. mcp &lt;- st_convex_hull(wildschwein_BE_smry) Task 5: Ploting spatial objects Using base plot to visualize sf objects is easy enough, just try the following code. plot(mcp) But since we use ggplot extensively, try and plot the object mcp with ggplot. Hint: Use the layer geom_sf() to add an sf object. Note: ggplot refuses to use our specified CRS, so we need to force this by specifying datum = in coord_sf(). Try it out. Input: Importing raster data In the next task, we would like to add a background map to our mcp object. To do this, we have to the raster data into R first. For this, we use the package raster with the function brick. library(raster) pk100_BE &lt;- brick(&quot;00_Rawdata/pk100_BE_2056.tif&quot;) pk100_BE ## class : RasterBrick ## dimensions : 1821, 2321, 4226541, 4 (nrow, ncol, ncell, nlayers) ## resolution : 5, 5 (x, y) ## extent : 2567000, 2578605, 1199996, 1209101 (xmin, xmax, ymin, ymax) ## crs : +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## source : /home/staff/bako/unix/Lehre/Master/Pattends_and_Trends/Unterrichtsunterlagen_FS2020/00_Rawdata/pk100_BE_2056.tif ## names : pk100_BE_2056.1, pk100_BE_2056.2, pk100_BE_2056.3, pk100_BE_2056.4 ## min values : 0, 0, 0, 0 ## max values : 255, 255, 255, 255 pk100_BE_2056.tif is a three layered geotiff File. The above console output shows some metadata including the resolution, extent and the names of our layers (pk100_BE_2056.1, pk100_BE_2056.2etc). For some reason, RasterBrick imported a fourth layer (pk100_BE_2056.4). plot() shows that the fourth layer is empty. We will remove this layer using subset(). plot(pk100_BE) pk100_BE &lt;- subset(pk100_BE,1:3) plot(pk100_BE) Task 6: Adding a background map There are multiple ways to add a background map in ggplot, many require additional packages. This is a good opportunity to get to know a completely different package for creating maps: tmap (“thematic map”). This package was developed with a syntax very similar to ggplot2, which makes it easy to learn. library(tmap) tm_shape(pk100_BE) + tm_rgb() As you can see, plotting layers in tmap is combined with the + sign, just as in ggplot2. In tmap however, each layer consists of two objects: a tm_shape() in which the data is called, and a tm_* object in which we define how the data is visualized (tm_rgb() states that it is plotted as an RGB Raster Layer). Add the object mcp to the plot in this manner. Read the vignette if you are having trouble. Task 7: Create an interactive map Rerun the tmap()... command from the previous task, but switch the plotting mode to “view”&quot; (tmap_mode(&quot;view&quot;)) beforehand. Omit the raster layer (pk100_BE), you won’t be needing it. References "],
["exercise-3.html", "Exercise 3 Learning Outcomes Prerequisites Preperation Tasks and Inputs", " Exercise 3 Learning Outcomes You are able to segment a trajectory, e.g. using the approach proposed in Laube and Purves (2011) You are able to compute the similarity between given trajectories using the package SimilarityMeasures. You acquire further useful data processing skills. Prerequisites Readings Skills from “R for Data Science” (Wickham and Grolemund 2017): RS3.1 Chap1 Data visualization with ggplot2 (31, 3-35) RS3.2 Chap5 Exploratory Data Analysis (28p, 81.109) Readings Theory: Alan Both (2018) A Comparative Analysis of Trajectory Similarity Measures: Recommendations for Selection and Use, excerpt from an unpublished manuscript, confidential. Preperation Install the following libraries: install.packages(&quot;SimilarityMeasures&quot;) # The following packages are for optional tasks: install.packages(&quot;plotly&quot;) # You don&#39;t really need the following packages, # we just use them in our figures install.packages(&quot;ggrepel&quot;) Open your R Project from last week. Either run your own script from last week or the following lines to transform the data into the form we need for today’s exercise. library(tidyverse) library(sf) # Import as dataframe wildschwein_BE &lt;- read_delim(&quot;00_Rawdata/wildschwein_BE.csv&quot;,&quot;,&quot;) # Convert to sf-object wildschwein_BE = st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326,remove = FALSE) # transform to CH1903 LV95 wildschwein_BE &lt;- st_transform(wildschwein_BE, 2056) # Add geometry as E/N integer Columns wildschwein_BE &lt;- st_coordinates(wildschwein_BE) %&gt;% cbind(wildschwein_BE,.) %&gt;% rename(E = X) %&gt;% rename(N = Y) # Compute timelag, steplength and speed wildschwein_BE &lt;- wildschwein_BE %&gt;% group_by(TierID) %&gt;% mutate( timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;)), steplength = sqrt((E-lead(E))^2+(N-lead(N))^2), speed = steplength/timelag ) Tasks and Inputs Input: Segmentation as in Laube and Purves (2011) You’ve read Laube and Purves (2011) about segmenting trajectories. In the paper, the authors define “static” fixes as “those whose average Euclidean distance to other fixes inside a temporal window v is less than some threshold d”, as illustrated in the following figure: The above image from Laube and Purves (2011) visualizes the following steps: Temporal representation of constant sample interval with associated temporal window v for three exemplary points; Measurement of average distance in temporal window v to sample points in spatial representation; Removal of all points where average distance is less than a given threshold, i.e. removal of static points; and Removal of subtrajectories with less than a threshold temporal length. We will implement this method on the following dummy data. Once you’ve grasped the idea on this simple data, you will implement it for the wild boar data in task 1. Note: I use tibble() instead of data.frame(). The two functions are very similar, this is just a matter of preference. set.seed(10) n = 20 df &lt;- tibble(X = cumsum(rnorm(n)), Y = cumsum(rnorm(n))) ggplot(df, aes(X,Y)) + geom_path() + geom_point() + coord_equal() Segmenting The first step is calculating the distances to temporally close samples within the temporal window v. Take the following sample data, assuming the sampling interval is 5 minutes. If we take a temporal window of 20 minutes, that would mean including 5 fixes. We need to calculate the following Euclidean distances (pos representing single location): pos[n-2] to pos[n] pos[n-1] to pos[n] pos[n] to pos[n+1] pos[n] to pos[n+2] Just like last week, we use the formular for calculating the Euclidean distance in in combination with lead() and lag(). For example, to create the necessary offset of n-2, we use lag(x, 2). For each offset, we create one individual column. df &lt;- df %&gt;% mutate( nMinus2 = sqrt((lag(X,2)-X)^2+(lag(Y,2)-Y)^2), # distance to pos -10 minutes nMinus1 = sqrt((lag(X,1)-X)^2+(lag(Y,1)-Y)^2), # distance to pos - 5 minutes nPlus1 = sqrt((X-lead(X,1))^2+(Y-lead(Y,1))^2), # distance to pos + 5 mintues nPlus2 = sqrt((X-lead(X,2))^2+(Y-lead(Y,2))^2) # distance to pos +10 minutes ) Now we want to calculate the mean distance of nMinus2, nMinus1, nPlus1, nPlus2 for each row. The below function calculates the overall mean of all columns, which is not what we want. df %&gt;% mutate( stepMean = mean(c(nMinus2, nMinus1,nPlus1,nPlus2), na.rm = T) ) ## # A tibble: 20 x 7 ## X Y nMinus2 nMinus1 nPlus1 nPlus2 stepMean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.0187 -0.596 NA NA 2.19 3.26 1.72 ## 2 -0.166 -2.78 NA 2.19 1.53 3.42 1.72 ## 3 -1.54 -3.46 3.26 1.53 2.20 3.40 1.72 ## 4 -2.14 -5.58 3.42 2.20 1.30 1.78 1.72 ## 5 -1.84 -6.84 3.40 1.30 0.540 1.34 1.72 ## 6 -1.45 -7.21 1.78 0.540 1.39 2.21 1.72 ## 7 -2.66 -7.90 1.34 1.39 0.945 2.22 1.72 ## 8 -3.02 -8.77 2.21 0.945 1.63 1.92 1.72 ## 9 -4.65 -8.88 2.22 1.63 0.361 2.27 1.72 ## 10 -4.91 -9.13 1.92 0.361 2.16 2.68 1.72 ## 11 -3.80 -11.0 2.27 2.16 0.760 1.03 1.72 ## 12 -3.05 -11.1 2.68 0.760 0.997 1.38 1.72 ## 13 -3.29 -10.1 1.03 0.997 1.00 2.10 1.72 ## 14 -2.30 -9.91 1.38 1.00 1.57 2.94 1.72 ## 15 -1.56 -11.3 2.10 1.57 1.44 1.38 1.72 ## 16 -1.47 -12.7 2.94 1.44 1.02 1.81 1.72 ## 17 -2.42 -12.4 1.38 1.02 1.77 2.21 1.72 ## 18 -2.62 -14.1 1.81 1.77 0.981 1.71 1.72 ## 19 -1.69 -14.4 2.21 0.981 0.811 NA 1.72 ## 20 -1.21 -15.1 1.71 0.811 NA NA 1.72 Since we want the mean value per Row, we have to explicitly specify this before mutate() with the function rowwise(). Note the new grouping variable &lt;by row&gt; when printing the dataframe to the console. df &lt;- df %&gt;% rowwise() %&gt;% mutate( stepMean = mean(c(nMinus2, nMinus1,nPlus1,nPlus2)) ) df ## Source: local data frame [20 x 7] ## Groups: &lt;by row&gt; ## ## # A tibble: 20 x 7 ## X Y nMinus2 nMinus1 nPlus1 nPlus2 stepMean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.0187 -0.596 NA NA 2.19 3.26 NA ## 2 -0.166 -2.78 NA 2.19 1.53 3.42 NA ## 3 -1.54 -3.46 3.26 1.53 2.20 3.40 2.60 ## 4 -2.14 -5.58 3.42 2.20 1.30 1.78 2.17 ## 5 -1.84 -6.84 3.40 1.30 0.540 1.34 1.64 ## 6 -1.45 -7.21 1.78 0.540 1.39 2.21 1.48 ## 7 -2.66 -7.90 1.34 1.39 0.945 2.22 1.47 ## 8 -3.02 -8.77 2.21 0.945 1.63 1.92 1.68 ## 9 -4.65 -8.88 2.22 1.63 0.361 2.27 1.62 ## 10 -4.91 -9.13 1.92 0.361 2.16 2.68 1.78 ## 11 -3.80 -11.0 2.27 2.16 0.760 1.03 1.55 ## 12 -3.05 -11.1 2.68 0.760 0.997 1.38 1.45 ## 13 -3.29 -10.1 1.03 0.997 1.00 2.10 1.28 ## 14 -2.30 -9.91 1.38 1.00 1.57 2.94 1.72 ## 15 -1.56 -11.3 2.10 1.57 1.44 1.38 1.62 ## 16 -1.47 -12.7 2.94 1.44 1.02 1.81 1.80 ## 17 -2.42 -12.4 1.38 1.02 1.77 2.21 1.59 ## 18 -2.62 -14.1 1.81 1.77 0.981 1.71 1.57 ## 19 -1.69 -14.4 2.21 0.981 0.811 NA NA ## 20 -1.21 -15.1 1.71 0.811 NA NA NA We can now determin if an animal is moving or not by specifying a threshold on stepMean df &lt;- df %&gt;% mutate( moving = stepMean&gt;1.5 ) df ## Source: local data frame [20 x 8] ## Groups: &lt;by row&gt; ## ## # A tibble: 20 x 8 ## X Y nMinus2 nMinus1 nPlus1 nPlus2 stepMean moving ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 0.0187 -0.596 NA NA 2.19 3.26 NA NA ## 2 -0.166 -2.78 NA 2.19 1.53 3.42 NA NA ## 3 -1.54 -3.46 3.26 1.53 2.20 3.40 2.60 TRUE ## 4 -2.14 -5.58 3.42 2.20 1.30 1.78 2.17 TRUE ## 5 -1.84 -6.84 3.40 1.30 0.540 1.34 1.64 TRUE ## 6 -1.45 -7.21 1.78 0.540 1.39 2.21 1.48 FALSE ## 7 -2.66 -7.90 1.34 1.39 0.945 2.22 1.47 FALSE ## 8 -3.02 -8.77 2.21 0.945 1.63 1.92 1.68 TRUE ## 9 -4.65 -8.88 2.22 1.63 0.361 2.27 1.62 TRUE ## 10 -4.91 -9.13 1.92 0.361 2.16 2.68 1.78 TRUE ## 11 -3.80 -11.0 2.27 2.16 0.760 1.03 1.55 TRUE ## 12 -3.05 -11.1 2.68 0.760 0.997 1.38 1.45 FALSE ## 13 -3.29 -10.1 1.03 0.997 1.00 2.10 1.28 FALSE ## 14 -2.30 -9.91 1.38 1.00 1.57 2.94 1.72 TRUE ## 15 -1.56 -11.3 2.10 1.57 1.44 1.38 1.62 TRUE ## 16 -1.47 -12.7 2.94 1.44 1.02 1.81 1.80 TRUE ## 17 -2.42 -12.4 1.38 1.02 1.77 2.21 1.59 TRUE ## 18 -2.62 -14.1 1.81 1.77 0.981 1.71 1.57 TRUE ## 19 -1.69 -14.4 2.21 0.981 0.811 NA NA NA ## 20 -1.21 -15.1 1.71 0.811 NA NA NA NA ggplot(df, aes(X,Y)) + geom_path() + geom_point(aes(colour = moving)) + coord_equal() Unique IDs per segment When segmenting trajectories, we often want to compute metrics on the basis of each segment. Within the tidyverse logic, we need a unique ID per segment that we can pass to group_by(). In other words, we need a unique ID for a sequence of successive TRUE values. For lack of a better way, we suggest solving this problem with cumsum(). cumsum() returns the cummulative sum of a given vector: one_to_ten &lt;- 1:10 one_to_ten ## [1] 1 2 3 4 5 6 7 8 9 10 cumsum(one_to_ten) ## [1] 1 3 6 10 15 21 28 36 45 55 In R, TRUEand FALSE are interprated as 1 and 0 if coerced to an integer. as.integer(TRUE) ## [1] 1 as.integer(FALSE) ## [1] 0 TRUE+TRUE ## [1] 2 Therefore, cumsum() on a boolean vector increases the count on each TRUE value: boolvec &lt;- c(FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,TRUE) df_cumsum &lt;- tibble(boolvec = boolvec,cumsum = cumsum(boolvec)) df_cumsum ## # A tibble: 8 x 2 ## boolvec cumsum ## &lt;lgl&gt; &lt;int&gt; ## 1 FALSE 0 ## 2 TRUE 1 ## 3 TRUE 2 ## 4 TRUE 3 ## 5 FALSE 3 ## 6 FALSE 3 ## 7 TRUE 4 ## 8 TRUE 5 You might have noticed that this is pretty much exactly the opposite of what we need. We therefore have to take the inverse of the boolean vector: df_cumsum %&gt;% mutate( boolvec_inverse = !boolvec, cumsum2 = cumsum(boolvec_inverse) ) ## # A tibble: 8 x 4 ## boolvec cumsum boolvec_inverse cumsum2 ## &lt;lgl&gt; &lt;int&gt; &lt;lgl&gt; &lt;int&gt; ## 1 FALSE 0 TRUE 1 ## 2 TRUE 1 FALSE 1 ## 3 TRUE 2 FALSE 1 ## 4 TRUE 3 FALSE 1 ## 5 FALSE 3 TRUE 2 ## 6 FALSE 3 TRUE 3 ## 7 TRUE 4 FALSE 3 ## 8 TRUE 5 FALSE 3 To simplify our workflow, we can we can take the inverse of boolvec within our cumsum() statement and save an extra line of code. df_cumsum %&gt;% mutate( cumsum2 = cumsum(!boolvec) ) ## # A tibble: 8 x 3 ## boolvec cumsum cumsum2 ## &lt;lgl&gt; &lt;int&gt; &lt;int&gt; ## 1 FALSE 0 1 ## 2 TRUE 1 1 ## 3 TRUE 2 1 ## 4 TRUE 3 1 ## 5 FALSE 3 2 ## 6 FALSE 3 3 ## 7 TRUE 4 3 ## 8 TRUE 5 3 Task 1: Segmentation With the skills from the input above we can now implement the segmentation algorithm described in Laube and Purves (2011). The described method depends on a regular sampling interval. Therefore, take the dataset “caro60.csv” from task 3 of last week (available on moodle). Import it as a dataframe, we don’t need an sf-object to for today’s tasks. Next, we have to have to define our temporal window v (Laube and Purves 2011). To keep things simple, I would suggest a window of n +/- 2 minutes. With a sampling interval of around 1 minute, this corresponds to a window size of n +/- 2 positions. Task 2: Specify and apply threshold d After calculating the Euclidean distances to positions within the temporal window v in task 1, you can explore these values (we stored them in the column stepMean) using summary statistics (histograms, boxplot, summary()): This way we can define a reasonable threshold value to differentiate between “stops” and “moves”. There is no “correct” way of doing this, specifying a threshold always depends on data as well as the question that needs to be answered. In this exercise, find a threshold that matches your intuition. Store the new information (boolean to differentiate between stops (TRUE) and moves (FALSE)) in a new column named moving. ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0.8109 2.2397 3.3496 5.0371 5.8618 24.2903 4 Figure 1: My summary statistics shows a mean of 5, the histogram shows that this might be a reasonable threshold. Task 3: Visualize segmented trajectories Now visualize the segmented trajectory spatially. Just like last week, you can use ggplot with geom_path(), geom_point() and coord_equal(). Assign colour = moving within aes() to distinguish between segments with “movement” and without. Tip: if you want to get a ggplot() with Zoom capability, just load the library plotly and wrap the ggplot() function with ggplotly() Figure 2: This is the same plot as above, wrapped in the function ggplotly() from the library plotly. With this function, the plot becomes interactive. Try it out! Task 4: Segment-based analysis In applying Laube and Purves (2011), we’ve come as far as steps (b)/(c) in Figure 1. In order to complete step (d) (Removal of subtrajectories with less than a threshold temporal length), we have to calculate each segment’s temporal duration. In order to do this, we need a unique name for each segment that we can use as a grouping variable. This is where the cumsum() approach which we introduced in the input comes useful. Complete the following steps: Filter the data by removing all rows where moving equals to NA (typically these are the the first and last 2 rows). Get a unique ID per segment and using the cumsum() approach we introduced in the input. Store this ID in a new column segment_ID Filter the data to remove all rows where the animal is not moving Group by the column segment_ID to calculate the temporal length of each segment with mutate(). Remove segments with a duration less than 3 minutes inspect your data visually Task 5: Similarity measures Import the dataset pedestrian.csv (available on moodle) as a dataframe (you don’t need an sf object). It it a set of six different but similar trajectories from pedestrians walking on a path. Explore this data visually. We will analyse these trajectories with the package SimilarityMeasures, always comparing trajectory 1 pairwise to the other trajectories 2-6. For this task, explore the trajectories first and get an idea on how the pedestrians moved. We step away from using the wild boar data for this task because our animals don’t express the type of similarity we want to illustrate here. Also, using the constructed pedestrian data allows us illustrating very typical similarity issues, that are picked-up in different ways by the different similarity measures. In later exercises we will get back to our wild boar! Figure 3: Comparing Trajectories 1 and 2 Figure 4: Comparing Trajectories 1 and 3. Some positions are labelled with the position index to illustrate the direction of movement per trajectory. Figure 5: Comparing Trajectories 1 and 4 Figure 6: Comparing Trajectories 1 and 5 Figure 7: Comparing Trajectories 1 and 6 Task 6: Calculate similarity Calculate the similarity between trajectory 1 and trajectories 2-6. Use the different similarity measures in the package SimilarityMeasures. Visualize your results and try to understand the different results with respect to your reading of Alan Both (2018). Can you see connections between the properties of the trajectories and the similarity values computed by the different measures? Note: All functions in the package need matrices as input, with one trajectory per matrix. LCSStakes very long to compute. The accuracy of the algorithm (pointSpacing = ,pointDistance = and errorMarg =) can be varied to provide faster calculations. Please see Vlachos, Gunopoulos, and Kollios (2002) for more information. Figure 8: Comparing Trajectory 1 to trajectories 2 to 6 "]
]
