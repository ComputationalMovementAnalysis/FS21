[
["index.html", "Patterns and Trends in Environmental Data Master ENR, Spring Semester 2019 Introduction Chapter", " Patterns and Trends in Environmental Data Master ENR, Spring Semester 2019 Patrick Laube and Nils Ratnaweera 02 May, 2019 Introduction Chapter For our practical R course building-up skills for analyzing movement data in the software environment R, you’ll be using data from the ZHAW project “Prävention von Wildschweinschäden in der Landwirtschaft”. The project investigates the spatiotemporal movement patterns of wild boar (Sus scrofa) in agricultural landscapes. We will study the trajectories of these wild boar, practicing the most basic analysis tasks of Computational Movement Analysis (CMA). Please note: we are given application data from an ongoing research project. Capturing wild living animals and then equipping them with GPS collars is a very labor and cost intensive form of research. Consequently, data resulting such campaigns is a very valuable asset that must be protected. So, please do not pass on this data, for any use beyond this module contact Patrick Laube or the data owner Stefan Suter (suts@zhaw.ch). "],
["exercise-1.html", "Exercise 1 Leaning outcomes Prerequisites Preperation Tasks and inputs", " Exercise 1 Exercise 1 covers the necessary steps for getting ready in R and some basic concepts for setting up a well-structured R project. The lesson introduces how additional packages that provide useful functions for data science are made available and how spatial data is handled. The exercise concludes with the creation of your first map featuring movement data. Leaning outcomes You learn how to structure an R project. You can read movement data from a .csv-file into a data.frame You can convert spatial point data from a data.frame to a spatial object sf You can perform basic spatial operations on spatial objects in R You can produce simple maps of your spatial data using ggplot2 You can produce simple maps of your spatial data using tmap Prerequisites Readings Skills from “R for Data Science” (Wickham and Grolemund 2017): RS1.1 Preface (16p, ix-xxiv) RS1.2 Chap2 Workflow basics (3p, 37-39) RS1.3 Chap4 Workflow scripts (3p, 77-79) RS1.4 Chap6 workflow projects (6p, 111-116) RS1.5 Chap8 Data Import with readr (21p) RS1.6 Chap13 Date and Times with lubridate (18p, 237-256) Preperation If you haven’t already, install the packages tidyverse, and devtools (using install.packages()). Additionally, install the packages sf, raster and ggspatial. Restart your R session after installing all these packages. install.packages(&quot;tidyverse&quot;) install.packages(&quot;sf&quot;) install.packages(&quot;raster&quot;) Tasks and inputs Task 1: Initialize project Create a new RStudio Project. As recommended in Wickham and Grolemund (2017), remove the option “Restore .RData into workspace at startup” and set the option “save workspace to .RData on exit” to “Never”. Create a new .R (or .Rmd) File and divide it into the sections necessary in a classical Data Science Workflow. In .R Files, “Sections” can be created within RStudio by adding Comments (#) with at least 4 trailing dashes, equal, or pound signs ( -, =,#). In .Rmd Files, their are created with leading pound signs (#). Sections allow code folding (try clicking on the small triangle next to the line number) and facilitate navigation (try the shortcut: Shift+Alt+J). We recommend following sections: Loading environment / libraries Data import Data cleansing Data analysis and visualization Task 2: Import data In section “data import”, import the file wildschwein_BE.csv. Obtain this file from moodle. Note: If your are using a graphical tool to import your code, make sure you save the corresponding code in your R Script. This is important in regard to the reproducibility of your script and will ensure that your workflow is documented without gaps. We’d rather recommend to move away from using graphical tools and focus on using code. We recommend using one of the tidyverse functions from the readr package to import your data (they all begin with “read_*, note the underscore). These functions are less error prone than the base R functions (read.*). Specifically for the wild boar data, we recommend read_delim(). If you use read_delim() and receive warnings during import, have a look at these warnings by using the function problems(). Resolve these problems until import runs without warnings. Assign correct data types as necessary and make sure the time zone is set correctly for the date/time column. For everyone working on the RStudio Server: You will first need to upload this data to the server using the “upload”-button in the “Files” tab. Task 3: Explore Data We will use a range of different visualization tools (i.e. R-packages) in this course. Several packages techniques have emerged in recent years, each with their specific strengths and weaknesses. While base::plot()is quick and simple, it not very scalable with growing complexity. ggplot2 offers solutions for most use cases and has an elegant, consistent syntax that is easy to get accustomed to. We will get to know other techniques later in the course. Get an overview of your data by creating a first “map-like” plot of your data producing a simple scatter plot with ggplot2. Setting up a ggplot with our data is done using the command ggplot(wildschwein_BE, aes(Long, Lat, colour = TierID)). Creating a map is done via the basic scatter plot command geom_point(). Use coord_map() to get a reasonable aspect ratio of Lat and Long. Assigning every individual its own colour is done using the ggplot argument colour =. Save your code in the appropriate section. Input: Handling spatial data Until now, we’ve stored our location data within data frames as Lat/Long columns. This works well for many tasks, but sometimes we need special spatial classes to handle our trajectories. We will get to know such cases in our next tasks, but first we need to convert our data.frame into a spatial object. Some of you might be familiar with the sp package with the classes SpatialPoints, SpatialPointsDataFrame and so on. These packages are mostly replaced by the fairly new package sf. This packages has some huge advantages over sp: simple features are essentially data frames with minor extensions and thus are easily integratable in standard workflows they are programmed to cleanly interface with the tidyverse methods (specifically dplyr’s mutate and summarise) comply with the common Open Geospatial Consortium (OGC) standards (ISO 19125-1:2004) and interface with other important spatial tools such as GDAL, PostGIS, GeoJSON and so fourth are being rapidly implemented in visualisation tools such as ggplot2, plotly and tmap We will largely rely on sfwhen working with vector data in R. In order to transform our data.frame into an sf object, we need to use the function st_as_sf() while specifying the columns storing the coordinates and the coordinate reference system1. library(sf) wildschwein_BE_sf &lt;- st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) Notice how st_as_sf takes the EPSG code for the crs = argument. This is so much easier and more elegant than using PROJ.4 or WKT. You can find a lot of useful information on Coordinate Reference Systems (including EPSG Codes , etc.) under spatialreference.org or http://epsg.io. Let’s compare our original data.frame with this new sf object: wildschwein_BE ## # A tibble: 51,246 x 6 ## TierID TierName CollarID DatetimeUTC Lat Long ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 47.0 7.05 ## 2 002A Sabi 12275 2014-08-22 21:15:16 47.0 7.05 ## 3 002A Sabi 12275 2014-08-22 21:30:43 47.0 7.05 ## 4 002A Sabi 12275 2014-08-22 21:46:07 47.0 7.05 ## 5 002A Sabi 12275 2014-08-22 22:00:22 47.0 7.05 ## 6 002A Sabi 12275 2014-08-22 22:15:10 47.0 7.05 ## 7 002A Sabi 12275 2014-08-22 22:30:13 47.0 7.05 ## 8 002A Sabi 12275 2014-08-22 22:45:11 47.0 7.05 ## 9 002A Sabi 12275 2014-08-22 23:00:27 47.0 7.05 ## 10 002A Sabi 12275 2014-08-22 23:15:41 47.0 7.05 ## # ... with 51,236 more rows wildschwein_BE_sf ## Simple feature collection with 51246 features and 4 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 7.019889 ymin: 46.97125 xmax: 7.112075 ymax: 47.01882 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## # A tibble: 51,246 x 5 ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [°]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (7.049618 46.99317) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (7.049509 46.99416) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (7.049406 46.99383) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (7.049217 46.99375) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (7.049359 46.99375) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (7.049363 46.99382) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (7.049326 46.99387) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (7.049237 46.99395) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (7.048383 46.99481) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (7.049396 46.99373) ## # ... with 51,236 more rows As you can see, st_as_sf() has added some metadata to our dataframe (geometry type, dimension, bbox, epsg and proj4string) and replaced the columns Lat and Long with a column named geometry. Other than that, the new sf object is very similar to our original dataframe. In fact, sf objects are essentially dataframes, just ask R: is.data.frame(wildschwein_BE_sf) ## [1] TRUE All operations we know from handling data.frames can be used on the sf object. Try some out! # subset rows wildschwein_BE_sf[1:10,] wildschwein_BE_sf[wildschwein_BE_sf$TierName == &quot;Sabi&quot;,] # subset colums wildschwein_BE_sf[,2:3] Instead of keeping the same data twice (once as a data.frame, and once as an sf object), we will overwrite the data.frame and continue working with the sf object from now on. This saves some memory space in R and avoids confusion. wildschwein_BE = st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) rm(wildschwein_BE_sf) # we can remove this sf object, since it just eats up our memory Task 4: Project data from WGS84 So what can we do with our new sf object that we couldn’t before? One example is projecting the WGS84 (Lat/Long) coordinates into the new Swiss CRS CH1903+ LV952. Do this by using the function st_transform. By the way, do you notice a pattern here? The package sf names most functions for spatial operations with the prefix st_*, just as in PostGIS. Here’s the resulting sf object from the operation: ## Simple feature collection with 51246 features and 4 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 51,246 x 5 ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [m]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (2570409 1204752) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (2570402 1204863) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (2570394 1204826) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (2570379 1204817) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (2570390 1204818) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (2570390 1204825) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (2570387 1204831) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (2570381 1204840) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (2570316 1204935) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (2570393 1204815) ## # ... with 51,236 more rows Input: Calculate Convex Hull Transforming from one Coordinate Reference System to another was one operation where we needed an object with a spatial nature. In this way, we were able to use an off the shelf function to project the coordinates from one CRS to another. In our next example, we again rely on a spatial function: We want to calculate a convex hull per Wild boar. And guess what the function for calculating a convex hull is called in sf? If you guessed st_convex_hull(), you were right! By default st_convex_hull() calculates the convex hull per feature, i.e. per point in our dataset. This of course makes little sense. In order to calculate the convex hull per animal, we need to convert our point- to multipoint-features where each feature contains all positions of one animal. This is achieved in two steps: First: add a grouping variable to the sf object. Note the new grouping variable in the metadata of the sf object. Other than that, group_by has no effect on our sf object. wildschwein_BE_grouped &lt;- group_by(wildschwein_BE,TierID) wildschwein_BE_grouped ## Simple feature collection with 51246 features and 4 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 51,246 x 5 ## # Groups: TierID [3] ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [m]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (2570409 1204752) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (2570402 1204863) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (2570394 1204826) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (2570379 1204817) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (2570390 1204818) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (2570390 1204825) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (2570387 1204831) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (2570381 1204840) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (2570316 1204935) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (2570393 1204815) ## # ... with 51,236 more rows Second: use summarise() to “dissolve” all points into a mulipoint object. wildschwein_BE_smry &lt;- summarise(wildschwein_BE_grouped) wildschwein_BE_smry ## Simple feature collection with 3 features and 1 field ## geometry type: MULTIPOINT ## dimension: XY ## bbox: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 3 x 2 ## TierID geometry ## &lt;chr&gt; &lt;MULTIPOINT [m]&gt; ## 1 002A (2568903 1206200, 2568925 1206207, 2568980 1206197, 2569024 12063… ## 2 016A (2569231 1205823, 2569245 1205925, 2569247 1206027, 2569251 12058… ## 3 018A (2568153 1205611, 2568155 1205613, 2568161 1205624, 2568162 12056… Now we can run st_convex_hull on the new sf object. mcp &lt;- st_convex_hull(wildschwein_BE_smry) Task 5: Ploting spatial objects Using base plot to visualize sf objects is easy enough, just try the following code. plot(mcp) But since we use ggplot extensively, try and plot the object mcp with ggplot. Hint: Use the layer geom_sf() to add an sf object. Note: ggplot refuses to use our specified CRS, so we need to force this by specifying datum = in coord_sf(). Try it out. Input: Importing raster data In the next task, we would like to add a background map to our mcp object. To do this, we have to the raster data into R first. For this, we use the package raster with the function brick. library(raster) pk100_BE &lt;- brick(&quot;00_Rawdata/pk100_BE_2056.tif&quot;) pk100_BE ## class : RasterBrick ## dimensions : 1821, 2321, 4226541, 4 (nrow, ncol, ncell, nlayers) ## resolution : 5, 5 (x, y) ## extent : 2567000, 2578605, 1199996, 1209101 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## data source : /home/staff/rata/unix/Master/PatternsAndTrends/2019_FS/Unterrichtsunterlagen/00_Rawdata/pk100_BE_2056.tif ## names : pk100_BE_2056.1, pk100_BE_2056.2, pk100_BE_2056.3, pk100_BE_2056.4 ## min values : 0, 0, 0, 0 ## max values : 255, 255, 255, 255 pk100_BE_2056.tif is a three layered geotiff File. The above console output shows some metadata including the resolution, extent and the names of our layers (pk100_BE_2056.1, pk100_BE_2056.2etc). For some reason, RasterBrick imported a fourth layer (pk100_BE_2056.4). plot() shows that the fourth layer is empty. We will remove this layer using subset(). plot(pk100_BE) pk100_BE &lt;- subset(pk100_BE,1:3) plot(pk100_BE) Task 6: Adding a background map There are multiple ways to add a background map in ggplot, many require additional packages. This is a good opportunity to get to know a completely different package for creating maps: tmap (“thematic map”). This package was developed with a syntax very similar to ggplot2, which makes it easy to learn. library(tmap) tm_shape(pk100_BE) + tm_rgb() As you can see, plotting layers in tmap is combined with the + sign, just as in ggplot2. In tmap however, each layer consists of two objects: a tm_shape() in which the data is called, and a tm_* object in which we define how the data is visualized (tm_rgb() states that it is plotted as an RGB Raster Layer). Add the object mcp to the plot in this manner. Read the vignette if you are having trouble. Task 7: Create an interactive map Rerun the tmap()... command from the previous task, but switch the plotting mode to “view”&quot; (tmap_mode(&quot;view&quot;)) beforehand. References "],
["exercise-2.html", "Exercise 2 Learning Outcomes Prerequisites Preperation Demo Tidyverse Tasks and Inputs Solutions", " Exercise 2 Learning Outcomes You understand the dplyr functions mutate, summarise and group_by and can apply them to sf objects You can derive movement parameters (timelag, steplength, speed) from trajectory data. You can re-sample your trajectory data for cross scale movement analysis. Prerequisites Readings Skills from “R for Data Science” (Wickham and Grolemund 2017): RS2.1 Chap3 Data Transformation with dplyr (31p, 43-76) RS2.2 Chap10 Relational data with dplyr (21p, 171-193) RS2.3 Chap14 Pipes with magrittr (6p, 261-268) Readings Theory R2.1 Laube and Purves (2011): How fast is a cow? cross - scale analysis of movement data. Preperation Install the package zoo to get access to the rolling window functions for last exercise. install.packages(&quot;zoo&quot;) Import the wild boar data and convert it to an sf object with CH1903+ LV95 Coordinates. Either run your own script from last week or the following lines to bring the data to the form we need it for today exercise. library(tidyverse) library(sf) library(lubridate) wildschwein_BE &lt;- read_delim(&quot;00_Rawdata/wildschwein_BE.csv&quot;,&quot;,&quot;) wildschwein_BE = st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) wildschwein_BE &lt;- st_transform(wildschwein_BE, 2056) Demo Tidyverse Depending on your knowledge of R, getting an overview of the data we imported last week might have been quite a challenge. Surprisingly enough, importing, cleaning and exploring your data can be the most challenging, time consuming part of a project. RStudio and the tidyverse offer many helpful tools to make this part easier (and more fun). You have read chapters on dplyr and magrittr as a preparation for this Exercise. Before we start with the Exercise however, this demo illustrates a simple approach offered by tidyverse which is applicable to sf-objects. Assume we want to calculate the timelag in between subsequent positions. To achieve this we can use the function difftime() combined with lead() from dplyr. Let’s look at these functions one by one. difftime difftime takes two POSIXct values. now &lt;- Sys.time() later &lt;- now + 10000 time_difference &lt;- difftime(later,now) You can also specify the unit of the output. time_difference &lt;- difftime(later,now,units = &quot;mins&quot;) difftime returns an object of the Class difftime. However in our case, numeric values would be more handy than the Class difftime. So we’ll wrap the command in as.numeric(): str(time_difference) ## Class &#39;difftime&#39; atomic [1:1] 167 ## ..- attr(*, &quot;units&quot;)= chr &quot;mins&quot; time_difference &lt;- as.numeric(difftime(later,now,units = &quot;mins&quot;)) str(time_difference) ## num 167 lead() / lag() lead() and lag() return a vector of the same length as the input, just offset by a specific number of values (default is 1). Consider the following sequence: numbers &lt;- 1:10 numbers ## [1] 1 2 3 4 5 6 7 8 9 10 We can now run lead() and lag() on this sequence to illustrate the output. n = specifies the offset, default = specifies the default value used to “fill” the emerging “empty spaces” of the vector. lead(numbers) ## [1] 2 3 4 5 6 7 8 9 10 NA lead(numbers,n = 2) ## [1] 3 4 5 6 7 8 9 10 NA NA lag(numbers) ## [1] NA 1 2 3 4 5 6 7 8 9 lag(numbers,n = 5) ## [1] NA NA NA NA NA 1 2 3 4 5 lag(numbers,n = 5, default = 0) ## [1] 0 0 0 0 0 1 2 3 4 5 This helps us performing operations on subsequent values in a vector (or rows in a table). You can think of this a little bit like a moving temporal window that moves along the trajectory, or down the rows of a table respectively. mutate() Using the above functions (difftime() and lead()), we can calculate the time lag, that is, the time difference between subsequent positions: wildschwein_BE$timelag &lt;- as.numeric(difftime(lead(wildschwein_BE$DatetimeUTC),wildschwein_BE$DatetimeUTC,units = &quot;secs&quot;)) We mention wildschwein_BE three times in this function, which is complicated. Instead, we can use mutate() to simplify the syntax: wildschwein_BE &lt;- mutate(wildschwein_BE,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;))) group_by() Now let’s have a look at the vector created before: summary(wildschwein_BE$timelag) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## -22648470 896 903 571 916 60367 1 These values don’t make much sense: some are negative (which should not be the case) and some are very high (which would indicate large data gaps and should not be the case either). The reason for this result is that we did not consider that timelag should just be calculated between subsequent rows of the same individual. We can implement this by using group_by() (just as if calculating the convex hull last week). wildschwein_BE &lt;- group_by(wildschwein_BE,TierID) After adding this grouping variable, calculating the timelag automatically accounts for the individual trajectories. wildschwein_BE &lt;- mutate(wildschwein_BE,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;))) summary(wildschwein_BE$timelag) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 12 896 903 1408 916 60367 3 summarise() summary() returned the metrics over all individuals. If we want to summarise our data and get metrics per animal, we can use the dplyr function summarise(). In contrast to mutate(), which just adds a new column to the dataset, summarise() “collapses” the data to one row per individual (specified by group_by). summarise(wildschwein_BE, mean = mean(timelag, na.rm = T)) The above operation works fine on normal data.frames, but since wildschwein_BE is also an sf object, summarise actually merges all the points to a multipoint geometry, which takes a long time to calculate. In order to prevent this, we can set the objects geometry to NULL, which removes the spatial attribute. summarise(st_set_geometry(wildschwein_BE,NULL), mean_timelag = mean(timelag, na.rm = T)) ## # A tibble: 3 x 2 ## TierID mean_timelag ## &lt;chr&gt; &lt;dbl&gt; ## 1 002A 1286. ## 2 016A 1412. ## 3 018A 1599. Piping The code above hard to read, since it has so many nested functions which need to be read from the inside out. In order to make code readable in a more human-friendly way, we can use the piping command %&gt;% from magrittr, which is included in dplyr and the tidyverse. The above code then looks like this: wildschwein_BE %&gt;% # Take wildschwein_BE... st_set_geometry(NULL) %&gt;% # ...remove the geometry column... group_by(TierID) %&gt;% # ...group it by TierID summarise( # Summarise the data... mean_timelag = mean(timelag,na.rm = T) # ...by calculating the mean timelag ) ## # A tibble: 3 x 2 ## TierID mean_timelag ## &lt;chr&gt; &lt;dbl&gt; ## 1 002A 1286. ## 2 016A 1412. ## 3 018A 1599. Bring it all together… Here is the same approach with a different, smaller dataset: pigs = data.frame( TierID=c(8001,8003,8004,8005,8800,8820,3000,3001,3002,3003,8330,7222), sex=c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;), age=c(&quot;A&quot;,&quot;A&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;A&quot;), weight=c(50.755,43.409,12.000,16.787,20.987,25.765,22.0122,21.343,12.532,54.32,11.027,88.08) ) pigs ## TierID sex age weight ## 1 8001 M A 50.7550 ## 2 8003 M A 43.4090 ## 3 8004 M J 12.0000 ## 4 8005 F A 16.7870 ## 5 8800 M J 20.9870 ## 6 8820 M J 25.7650 ## 7 3000 F J 22.0122 ## 8 3001 F A 21.3430 ## 9 3002 M J 12.5320 ## 10 3003 F J 54.3200 ## 11 8330 M A 11.0270 ## 12 7222 F A 88.0800 pigs %&gt;% summarise( mean_weight = mean(weight) ) ## mean_weight ## 1 31.58477 pigs %&gt;% group_by(sex) %&gt;% summarise( mean_weight = mean(weight) ) ## # A tibble: 2 x 2 ## sex mean_weight ## &lt;fct&gt; &lt;dbl&gt; ## 1 F 40.5 ## 2 M 25.2 pigs %&gt;% group_by(sex,age) %&gt;% summarise( mean_weight = mean(weight) ) ## # A tibble: 4 x 3 ## # Groups: sex [?] ## sex age mean_weight ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 F A 42.1 ## 2 F J 38.2 ## 3 M A 35.1 ## 4 M J 17.8 Tasks and Inputs Task 1: Getting an overview Calculate the time difference between subsequent rows as described in the demo (column timelag) First, inspect your data in more detail. Try to answer the following questions: How many individuals were tracked? How long were the individual tracked? Are there gaps? Were all individuals tracked concurrently or sequentially? What is the temporal sampling interval between the locations? Here are some exemplary visualisation you could produce to answer these questions. Can you now answer the above questions? Input: Geometry as columns Last week, we transformed our data from a data.frame to an sf object. This turned our Lat/Long Columns into a single geometry (list) column. While this is very handy for many spatial operations, accessing the coordinates directly becomes difficult. We therefore suggest storing the information twice, once as a geometry and once as a numeric value. To do this, we have to extract the Coordinates using st_coordinates(). We can store these values in a new variable and display them: # Store coordinates in a new variable coordinates &lt;- st_coordinates(wildschwein_BE) head(coordinates) ## X Y ## 1 2570409 1204752 ## 2 2570402 1204863 ## 3 2570394 1204826 ## 4 2570379 1204817 ## 5 2570390 1204818 ## 6 2570390 1204825 Note that that the column are named X and Y, while CH1903+ LV95 names the Axes E and N: let’s rename the columns appropriately. After this, we can use cbind() to “glue” the columns to our original sf-object. colnames(coordinates) &lt;- c(&quot;E&quot;,&quot;N&quot;) wildschwein_BE &lt;- cbind(wildschwein_BE,coordinates) head(wildschwein_BE) ## Simple feature collection with 6 features and 7 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2570379 ymin: 1204752 xmax: 2570409 ymax: 1204863 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## TierID TierName CollarID DatetimeUTC timelag E N ## 1 002A Sabi 12275 2014-08-22 21:00:12 904 2570409 1204752 ## 2 002A Sabi 12275 2014-08-22 21:15:16 927 2570402 1204863 ## 3 002A Sabi 12275 2014-08-22 21:30:43 924 2570394 1204826 ## 4 002A Sabi 12275 2014-08-22 21:46:07 855 2570379 1204817 ## 5 002A Sabi 12275 2014-08-22 22:00:22 888 2570390 1204818 ## 6 002A Sabi 12275 2014-08-22 22:15:10 903 2570390 1204825 ## geometry ## 1 POINT (2570409 1204752) ## 2 POINT (2570402 1204863) ## 3 POINT (2570394 1204826) ## 4 POINT (2570379 1204817) ## 5 POINT (2570390 1204818) ## 6 POINT (2570390 1204825) Task 2: Deriving movement parameters I: Speed In this task we will derive some additional movement parameters from our trajectories. So far our trajectories only consist of a list of time-stamped spatial locations. So let’s calculate the animal’s steplength based on the Euclidean distance between two subsequent locations. You can calculate the Euclidean distance with the following formula: sqrt((E1-E2)^2+(N1-N2)^2) use lead(E,1) to address the the row n+1 (i.e. E2) Now calculate the animals speed between subsequent locations based on the steplength as calculated in the previous task and the timelag between the locations. Task 3: Cross-scale movement analysis Laube and Purves (2011) analyse animal movement across different scales (see below). We will do the same on a subset of our data. Laube and Purves (2011): Black points are used in calculation of movement parameters (e.g. speed) at a given termporal scale. Import “Caro60” In the first task, we saw that the animals are sampled at different frequencies. To simplify the task, we’ve prepared a dataset that includes 200 locations of a single wild boar with a constant sampling interval of 60 seconds. Import this dataset named “caro60.csv” (available on moodle) just like you imported the other wild boar data. NOTE: We’ve converted the positions to CH1903+ LV95 for your convenience. Consider this when transforming to sf! Save this data to a new variable (we will use caro60). Resample Now manually reduce the granularity of our sampling interval by selecting every 3rd, 6th and 9th position. If you like to stick to the tidyverse approach, you can use slice() to subset the dataset by row number. Slice takes an integer vector. Eg: slice(dataset, 1:10), returns the first 10 rows of a dataset, slice(dataset, c(1,5,10)) returns the 1st, 5th and 10th value of a dataset. Save each re-sampled dataset in a new variable. We will use wildschwein_BE_3, wildschwein_BE_6 and wildschwein_BE_9. You should now have 4 data sets with different number of rows: nrow(caro60) ## [1] 200 nrow(caro60_3) ## [1] 67 nrow(caro60_6) ## [1] 34 nrow(caro60_9) ## [1] 23 Update derived parameters timelag, steplength and speed now have to be recalculated for the three re-sampled data sets. Do so as we illustrated in the Chapter Demo. Visualize Compare the speeds in a line plot and visualize the trajectories in a map (see examples below). Interpret the line plot, what do the different lines for the different temporal granularities tell you? We’ve stored the geographic location of our point in the trajectory in three different forms in our dataset. Once as a geometry, once as E/N and once as lat/long. In our view, it is most practical to use the E/N (integer) columns of our data to map them in this task geom_sf() does not plot lines, just points Therefore, use geom_path() and geom_point() rather than geom_sf() within ggplot In contrast to geom_sf(), you have to explicitly specify the x/y columns (in our case E/N) with geom_path()/geom_point() geom_line() does not work when mapping trajectory data, since it connects the observations in order of the variable on the x axis. geom_path() connects the observations in the order in which they appear in the data Task 4: Deriving movement parameters II: Rolling window functions A different approach would be to smoothen the derived parameters using a moving window function. The zoo package offers a variate of moving window functions (roll_*). Use roll_mean() to smooth the calculated speed. Familiarise yourself with this function by working on some dummy data, for example: library(zoo) example &lt;- rnorm(10) rollmean(example,k = 3,fill = NA,align = &quot;left&quot;) ## [1] -1.16251410 -0.82401159 -0.04738823 0.30164363 -0.05168042 ## [6] -0.38894958 -0.36146905 -0.58773447 NA NA rollmean(example,k = 4,fill = NA,align = &quot;left&quot;) ## [1] -0.948400097 -0.316482975 -0.034319639 -0.115274835 0.009813528 ## [6] -0.269880257 -0.782308411 NA NA NA Now run rollmeanon the speed variable of the subset (wildschwein_BE_1). Visualize the output from your moving windows and compare different window sizes (k =). Task 5 (optional): Calculate turning angles Just like we did with speed in tasks 2 - 4, we could do the same with turning angles of the trajectory. If you like a challenge, try to calculate these with the same approach! Warning: this task is pretty complex. Solutions Preperation library(tidyverse) library(sf) library(lubridate) wildschwein_BE &lt;- read_delim(&quot;00_Rawdata/wildschwein_BE.csv&quot;,&quot;,&quot;) wildschwein_BE = st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) wildschwein_BE &lt;- st_transform(wildschwein_BE, 2056) Demo Tidyverse now &lt;- Sys.time() later &lt;- now + 10000 time_difference &lt;- difftime(later,now) time_difference time_difference &lt;- difftime(later,now,units = &quot;mins&quot;) time_difference str(time_difference) time_difference &lt;- as.numeric(difftime(later,now,units = &quot;mins&quot;)) str(time_difference) numbers &lt;- 1:10 numbers lead(numbers) lead(numbers,n = 2) lag(numbers) lag(numbers,n = 5) lag(numbers,n = 5, default = 0) lead(numbers)-numbers wildschwein_BE$timelag &lt;- as.numeric(difftime(lead(wildschwein_BE$DatetimeUTC),wildschwein_BE$DatetimeUTC,units = &quot;secs&quot;)) wildschwein_BE &lt;- mutate(wildschwein_BE,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;))) summary(wildschwein_BE$timelag) wildschwein_BE &lt;- group_by(wildschwein_BE,TierID) wildschwein_BE &lt;- mutate(wildschwein_BE,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;))) summary(wildschwein_BE$timelag) ## summarise(wildschwein_BE, mean = mean(timelag, na.rm = T)) summarise(st_set_geometry(wildschwein_BE,NULL), mean_timelag = mean(timelag, na.rm = T)) wildschwein_BE %&gt;% # Take wildschwein_BE... st_set_geometry(NULL) %&gt;% # ...remove the geometry column... group_by(TierID) %&gt;% # ...group it by TierID summarise( # Summarise the data... mean_timelag = mean(timelag,na.rm = T) # ...by calculating the mean timelag ) pigs = data.frame( TierID=c(8001,8003,8004,8005,8800,8820,3000,3001,3002,3003,8330,7222), sex=c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;), age=c(&quot;A&quot;,&quot;A&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;A&quot;), weight=c(50.755,43.409,12.000,16.787,20.987,25.765,22.0122,21.343,12.532,54.32,11.027,88.08) ) pigs pigs %&gt;% summarise( mean_weight = mean(weight) ) pigs %&gt;% group_by(sex) %&gt;% summarise( mean_weight = mean(weight) ) pigs %&gt;% group_by(sex,age) %&gt;% summarise( mean_weight = mean(weight) ) Task 1 wildschwein_BE &lt;- wildschwein_BE %&gt;% mutate(timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;))) ggplot(wildschwein_BE, aes(DatetimeUTC,TierID)) + geom_line() ggplot(wildschwein_BE, aes(timelag)) + geom_histogram(binwidth = 50) + lims(x = c(0,15000)) + scale_y_log10() wildschwein_BE %&gt;% filter(year(DatetimeUTC) == 2014) %&gt;% ggplot(aes(DatetimeUTC,timelag, colour = TierID)) + geom_line() + geom_point() Input # Store coordinates in a new variable coordinates &lt;- st_coordinates(wildschwein_BE) head(coordinates) colnames(coordinates) &lt;- c(&quot;E&quot;,&quot;N&quot;) wildschwein_BE &lt;- cbind(wildschwein_BE,coordinates) head(wildschwein_BE) Task 2 wildschwein_BE &lt;- wildschwein_BE %&gt;% group_by(TierID) %&gt;% mutate( steplength = sqrt((E-lead(E))^2+(N-lead(N))^2) ) wildschwein_BE &lt;- wildschwein_BE %&gt;% group_by(TierID) %&gt;% mutate( speed = steplength/timelag ) Task 3 caro60 &lt;- read_delim(&quot;00_Rawdata/caro60.csv&quot;,&quot;,&quot;) %&gt;% st_as_sf(coords = c(&quot;E&quot;, &quot;N&quot;), crs = 2056, remove = FALSE) caro60_3 &lt;- caro60 %&gt;% slice(seq(1,nrow(.),3)) # the dot (&quot;.&quot;) represents the piped dataset caro60_6 &lt;- caro60 %&gt;% slice(seq(1,nrow(.),6)) caro60_9 &lt;- caro60 %&gt;% slice(seq(1,nrow(.),9)) nrow(caro60) nrow(caro60_3) nrow(caro60_6) nrow(caro60_9) caro60 &lt;- caro60 %&gt;% mutate( timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;)), steplength = sqrt((E-lead(E))^2+(N-lead(N))^2), speed = steplength/timelag ) caro60_3 &lt;- caro60_3 %&gt;% mutate( timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;)), steplength = sqrt((E-lead(E))^2+(N-lead(N))^2), speed = steplength/timelag ) caro60_6 &lt;- caro60_6 %&gt;% mutate( timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;)), steplength = sqrt((E-lead(E))^2+(N-lead(N))^2), speed = steplength/timelag ) caro60_9 &lt;- caro60_9 %&gt;% mutate( timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = &quot;secs&quot;)), steplength = sqrt((E-lead(E))^2+(N-lead(N))^2), speed = steplength/timelag ) ggplot() + geom_point(data = caro60, aes(E,N, colour = &quot;1 minute&quot;), alpha = 0.2) + geom_path(data = caro60, aes(E,N, colour = &quot;1 minute&quot;), alpha = 0.2) + geom_point(data = caro60_3, aes(E,N, colour = &quot;3 minutes&quot;)) + geom_path(data = caro60_3, aes(E,N, colour = &quot;3 minutes&quot;)) + labs(color=&quot;Trajectory&quot;, title = &quot;Comparing original- with 3 minutes-resampled data&quot;) + theme_minimal() ggplot() + geom_point(data = caro60, aes(E,N, colour = &quot;1 minute&quot;), alpha = 0.2) + geom_path(data = caro60, aes(E,N, colour = &quot;1 minute&quot;), alpha = 0.2) + geom_point(data = caro60_6, aes(E,N, colour = &quot;6 minutes&quot;)) + geom_path(data = caro60_6, aes(E,N, colour = &quot;6 minutes&quot;)) + labs(color=&quot;Trajectory&quot;, title = &quot;Comparing original- with 6 minutes-resampled data&quot;) + theme_minimal() ggplot() + geom_point(data = caro60, aes(E,N, colour = &quot;1 minute&quot;), alpha = 0.2) + geom_path(data = caro60, aes(E,N, colour = &quot;1 minute&quot;), alpha = 0.2) + geom_point(data = caro60_9, aes(E,N, colour = &quot;9 minutes&quot;)) + geom_path(data = caro60_9, aes(E,N, colour = &quot;9 minutes&quot;))+ labs(color=&quot;Trajectory&quot;, title = &quot;Comparing original- with 9 minutes-resampled data&quot;) + theme_minimal() ggplot() + geom_line(data = caro60, aes(DatetimeUTC,speed, colour = &quot;1 minute&quot;)) + geom_line(data = caro60_3, aes(DatetimeUTC,speed, colour = &quot;3 minutes&quot;)) + geom_line(data = caro60_6, aes(DatetimeUTC,speed, colour = &quot;6 minutes&quot;)) + geom_line(data = caro60_9, aes(DatetimeUTC,speed, colour = &quot;9 minutes&quot;)) + labs(x = &quot;Time&quot;,y = &quot;Speed (m/s)&quot;, title = &quot;Comparing derived speed at different sampling intervals&quot;) + theme_minimal() Task 4 library(zoo) example &lt;- rnorm(10) rollmean(example,k = 3,fill = NA,align = &quot;left&quot;) rollmean(example,k = 4,fill = NA,align = &quot;left&quot;) caro60 &lt;- caro60 %&gt;% mutate( speed3 = rollmean(speed,3,NA,align = &quot;left&quot;), speed6 = rollmean(speed,6,NA,align = &quot;left&quot;), speed9 = rollmean(speed,9,NA,align = &quot;left&quot;) ) caro60 %&gt;% gather(key,val,c(speed,speed3,speed6,speed9)) %&gt;% ggplot(aes(DatetimeUTC,val,colour = key,group = key)) + # geom_point() + geom_line() Task 5 References "],
["references.html", "References", " References "]
]
