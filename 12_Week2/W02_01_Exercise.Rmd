# Lesson 2
<!-- Enrich trajectories (step length, speed, 5min/3hrs) -->
<!-- Simple multi-scale analysis (with dplyr summarize for 5min and 3hrs) -->
<!-- Moving windows -->
<!-- Map back in space -->


## Learning Outcomes


## Prerequisites
Readings Skills from "R for Data Science" [@wickham2017]:

- RS2.1 Chap3 Data Transformation with `dplyr` (31p, 43-76)
- RS2.2 Chap10 Relational data with `dplyr` (21p, 171-193)
- RS2.3 Chap14 Pipes with `magrittr` (6p, 261-268)

Readings Theory
- R2.1 @laube2011: How fast is a cow? cross - scale analysis of movement data.

## Preperation

Open your R Project from last week. Load all libraries and run the scrip to import and clean your data. Install and load the following additional libraries.

<!-- Todo: add some comments as to what devtools does, and what CMAtools is -->
```{r, eval=F}
install.packages("devtools")
install.packages("zoo")

devtools::install_git("https://github.engineering.zhaw.ch/PatternsTrendsEnvironmentalData/CMAtools.git")
```

```{r}
library(CMAtools)
library(zoo)
```



## Tasks

### Task 1

Depending on your knowledge of `R`, getting an overview of the data we imported last week might have been quite a challenge. Quite surprisingly, importing, cleaning and exploring your data can be the most challenging, time consuming part of a project. RStudio and the tidyverse offer many extremely helpful tools to make this part easier, and more fun. 

To get an overview of the data, use the `dplyr` tools `group_by`, `summarise.` Try to answer the following questions:

- How many individuals were tracked? 
- How long were the individual tracked? Are there gaps?
- Were all individuals tracked concurrently or sequentially? 
- What is the temporal sampling interval between the locations?


```{r, results=F}
## Task 1 ####################

ggplot(wildschwein_BE_sf, aes(DatetimeUTC,TierID)) +
  geom_line()

wildschwein_BE_sf <- wildschwein_BE_sf %>%
  group_by(TierID) %>%
  mutate(
    timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = "mins"))
  )


ggplot(wildschwein_BE_sf, aes(timelag)) +
  geom_histogram(binwidth = 50)

ggplot(wildschwein_BE_sf, aes(timelag)) +
  geom_histogram(binwidth = 1) +
  lims(x = c(0,100)) +
  scale_y_log10()

wildschwein_BE_sf[1:50,] %>%
  ggplot(aes(DatetimeUTC,timelag)) +
  geom_line() +
  geom_point()


```

### Task 2

<!-- Todo: this task is not much fun, pretty difficult and maybe not even that important. remove?  -->

Now that we've established that we have different sampling intervals, we have to segment our trajectories in such a way, that we can perform further analysis during specific sampling intervals only. If we measure speed, or turning angles, we have to be very clear on what temporal (an thus spatial) scale we are performing this analysis. 

We therefore have to define threshold to group segments with a similar sampling interval. Explore the dataset in more detail (e.g. using histograms at different scales), and choose reasonable threshold values to group the trajectories into different sampling intervals. Use the function `cut()` to apply the thresholds on the column `timelag.` 

Note: 

- It might make more sense to choose narrow group intervals at smaller time lags and wider groups intervals at higher time lags.
- The function `cut` splits a vector into segments according to the values specified in breaks = . The default labels can be a bit puzzling at first, but `(` and `]` are [a standard form of notating intervals in mathematics](https://en.wikipedia.org/wiki/Interval_%28mathematics%29#Notations_for_intervals).
- Store the group names in a new column named `samplingInt`


```{r}
## Task 2 ####################

ggplot(wildschwein_BE_sf, aes(timelag)) +
  geom_histogram(binwidth = 0.1) +
  scale_x_continuous(breaks = seq(0,400,20),limits = c(0,400)) +
  # scale_x_continuous(breaks = seq(0,50,1),limits = c(0,50)) +
  scale_y_log10()

wildschwein_BE_sf <- wildschwein_BE_sf %>%
  group_by(TierID) %>%
  mutate(
    samplingInt = cut(timelag,breaks = c(0,5,seq(10,195,15)))
  ) 

wildschwein_BE_sf %>%
  group_by(samplingInt) %>%
  summarise(
    n = n()
  ) %>%
  ggplot(aes(samplingInt,n)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_log10()


```

### Task 3

Now that we've gotten the nifty job of specifying our intervals out of the way, let's get to a more fun part and calculate the speed of the animals movements. 

- If you're working with dplyr, you can add `samplingInt` to `group_by()` (in addition to TierID) and so make sure you're not calculating speed across different sampling intervals. 
- You can use the function `euclid()` from the `CMAtools` package to calculate Euclidean distances between subsequent rows. Use ?euclid to see what the function expects and returns. 
- use `lead(E,1)` to address the the row `n+1`
- make sure you're clear in what unit you are measuring speed. Meters per second is a SI base unit, but might be unhandy for the speeds travelled by wild boar.

```{r}
## Task 3 ####################

wildschwein_BE_sf <- wildschwein_BE_sf %>%
  group_by(TierID,samplingInt) %>%
  mutate(
    steplength = euclid(lead(E),lead(N),E,N),
    speed = steplength/timelag
  )



```
### Task 4

Measuring speed between subsequent samples is great, but especially for short sampling intervals they can be misleading due to measurement error. It might be desirable to *smoothen* these errors using a [moving window function](https://docs.wavefront.com/images/5sec_moving_window.png). The `zoo` package offers a variate of moving window functions (`roll*`). Use `roll_mean()` to smooth the calculated speed. Familiarise yourself with this function by working on some dummy data, for example:

```{r, include=T, results=F}
example <- rnorm(10)
rollmean(example,k = 3,fill = NA,align = "left")
rollmean(example,k = 4,fill = NA,align = "left")

```
Visualize the output from your moving windows and compare different window sizes (`k = `). 


```{r}
## Task 4 ####################


wildschwein_BE_sf <- wildschwein_BE_sf %>%
  group_by(TierID) %>%
  mutate(
    speed2 = rollmean(speed,3,NA,align = "left"),
    speed3 = rollmean(speed,5,NA,align = "left"),
    speed4 = rollmean(speed,10,NA,align = "left")
  )

wildschwein_BE_sf[1:30,] %>%
  gather(key,val,c(speed,speed2,speed3,speed4)) %>%
  ggplot(aes(DatetimeUTC,val,colour = key,group = key)) +
  geom_point() +
  geom_line() 
```

### Task 5

You've read @laube2011 about segmenting trajectories. In the paper, they define "*static*" fixes as "*those whose average Euclidean distance to other fixes inside a temporal window *v* is less than some threshold *d**". This sounds more complicated than it is, the figure illustrates the method nicely.

![](02_Images/laube_2011.jpg)

Try to implement this method on some dummy data. Once you've solved the problem on this simple data, we will implement it on the wild boar data next week. 

```{r, include = T, purl = F}
set.seed(10)
X = cumsum(rnorm(20))
Y = cumsum(rnorm(20))

plot(X,Y, type = "l")
```

Assume the sampling interval is 5 minutes. If we take a temporal window of 20 minutes, that would mean we include 5 fixes into the calculation. We need to calculate the following Euclidean distances (pos representing a `X`,`Y`-position):

1. pos[n-2] to pos[n]
2. pos[n-1] to pos[n]
3. pos[n] to pos[n+1]
4. pos[n] to pos[n+2]

You can use the function `euclid()` to calculate the distances and `dplyr` functions `lead()/``lag()` to create the necessary offsets. On our dummy data, we want to calculate the mean of the following distances (red, dotted lines).

```{r, purl = F, echo = F, include = T}
library(ggrepel)

df <- data.frame(X = X, Y = Y)

df <- df %>%
  mutate(
    Xm2 = lag(X,2),
    Ym2 = lag(Y,2),
    Xm1 = lag(X,1),
    Ym1 = lag(Y,1),    
    Xp1 = lead(X,1),
    Yp1 = lead(Y,1),    
    Xp2 = lead(X,2),
    Yp2 = lead(Y,2)
  )

n = 6
ggplot(df, aes(X,Y)) +
  geom_path() +
    geom_segment(data = df[n,], aes(x = Xm2,y = Ym2,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash",lwd = 1, colour = "red", inherit.aes = FALSE )+
    geom_segment(data = df[n,], aes(x = Xm1,y = Ym1,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash", lwd = 1, colour = "red", inherit.aes = FALSE )+
    geom_segment(data = df[n,], aes(x = Xp1,y = Yp1,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash", lwd = 1, colour = "red", inherit.aes = FALSE )+
    geom_segment(data = df[n,], aes(x = Xp2,y = Yp2,xend = X,yend = Y),
                 alpha = 0.8,lty = "twodash", lwd = 1, colour = "red", inherit.aes = FALSE ) +
  # coord_fixed(1) +
  geom_label_repel(data = df[n,], aes(x = X, y = Y),label = "pos n", nudge_x = 1) +
  geom_label_repel(data = df[n,], aes(x = Xp1, y = Yp1),label = "pos n+1",nudge_x = -1) +
  geom_label_repel(data = df[n,], aes(x = Xp2, y = Yp2),label = "pos n+2") +
  geom_label_repel(data = df[n,], aes(x = Xm2, y = Ym2),label = "pos n-2",nudge_y = 1) +
  geom_label_repel(data = df[n,], aes(x = Xm1, y = Ym1),label = "pos n-1") +
  theme_classic() +
  theme_classic(base_size = 16)


```

```{r}

## Task 5 ####################

nMinus2 <- euclid(lag(X, 2),lag(Y, 2),X,Y)  # distance to pos. -10 minutes
nMinus1 <- euclid(lag(X, 1),lag(Y, 1),X,Y)  # distance to pos.  -5 minutes
nPlus1  <- euclid(X,Y,lead(X, 1),lead(Y, 1)) # distance to pos   +5 mintues
nPlus2  <- euclid(X,Y,lead(X, 2),lead(Y, 2)) # distance to pos  +10 minutes

# Use cbind to bind all rows to a matrix
distances <- cbind(nMinus2,nMinus1,nPlus1,nPlus2)
distances

# This just gives us the overall mean
mean(distances, na.rm = T)

# We therefore need the function `rowMeans()`
rowmeans <- rowMeans(distances)
cbind(distances,rowmeans)

# and if we put it all together:
rowMeans(
  cbind(
    euclid(lag(X, 2),lag(Y, 2),X,Y),
    euclid(lag(X, 1),lag(Y, 1),X,Y),  
    euclid(X,Y,lead(X, 1),lead(Y, 1)), 
    euclid(X,Y,lead(X, 2),lead(Y, 2))
  )
)
```





## Solutions (RCode)

```{r code=readLines('12_Week2/RFiles/W02_01_Exercise.R'), results='asis', echo = T, include=T, eval=F}
```