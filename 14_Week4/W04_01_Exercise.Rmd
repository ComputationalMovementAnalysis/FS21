# Exercise 4

## Learning Outcomes
- You are able to conceptualize a simple movement pattern and implement data structures and corresponding procedures (let's call them algorithms...) for detecting it using R.
- You understand the sensitivity of movement patterns to pattern parameter thresholds.


## Prerequisites
Readings Skills from "R for Data Science" [@wickham2017]:

- RS4.1 Chap15 Functions (19p, 269-289)

Readings Theory, @laube2014
- R4.1 Chap.2, p. 29-58

## Preperation

```{r}
#- header3 Preperation
#- chunkstart
```

Open your R Project from last week. Either run your own script from last week or the following lines to transform the data into the form we need for today's exercise.

```{r, echo = T, include = T, eval = T}
library(tidyverse)
library(sf)
library(lubridate)

# Import as tibble
wildschwein_BE <- read_delim("00_Rawdata/wildschwein_BE.csv",",")

# Convert to sf-object
wildschwein_BE = st_as_sf(wildschwein_BE, coords = c("Long", "Lat"), crs = 4326,remove = FALSE)

# transform to CH1903 LV95
wildschwein_BE <- st_transform(wildschwein_BE, 2056)

# Add geometry as E/N integer Columns
wildschwein_BE <- st_coordinates(wildschwein_BE) %>%
  cbind(wildschwein_BE,.) %>%
  rename(E = X) %>%
  rename(N = Y)

# Compute timelag, steplength and speed
wildschwein_BE <- wildschwein_BE %>%
  group_by(TierID) %>%
  mutate(
    timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC,units = "secs")),
    steplength = sqrt((E-lead(E,1))^2+(N-lead(N,1))^2),
    speed = steplength/timelag
  )

```

```{r}
#- chunkend
```
## Tasks and inputs

### Input: Creating functions


```{r}
#- header3 Input
#- chunkstart
```

Up to now, we have used a variety of different functions designed by other developers. Sometimes we need to execute an operation multiple times, and most often it is reasonable to write a function to do so. Whenever youâ€™ve copied and pasted a block of code more than twice, you should consider writing a function [@wickham2017]. 

We have violated this rule multiple times when calculating the Euclidean distances between points. Writing and rewriting the code `sqrt((x-lead(x,1))^2+(y-lead(y,1))^2)` over and over again is not only cumbersome, it is also error prone. We can easily wrap this operation into a function. This input on writing functions should bring you up to speed to do this in your first task.

The first step in writing a function, is picking a name and assigning `<- function(){}` to it.


```{r, echo = T, include = T, eval = T}
testfun <- function(){}

```

To run the function, we have to call the assigned name with the brackets. This function gives no output, which is why we get `NULL` back. 
```{r, echo = T, include = T, eval = T}
testfun()

class(testfun)

```

To make the function actually *do* something, we need to specify *what* should be done within the curly brackets `{}`. The following function always prints the same statement and accepts no input values:

```{r, echo = T, include = T, eval = T}
testfun <- function(){print("this function does nothing")}

testfun()

```

If we want the function to accept some input values, we have to define them within the round brackets. For example, I specify a variable named `sometext` and can call this variable within the execution.


```{r, echo = T, include = T, eval = T}
testfun <- function(sometext){print(sometext)}

testfun(sometext = "this function does slightly more, but still not much")
```

Let's take a more practical example. Say we want a function that calculates the n^th^ root of a value, since the base function `sqrt()` just returns the 2^nd^ root. To do this, we need to know two things:

- taking the n^th^ rooth of x is the same as raising `x` by the the reciprocal value ("Kehrwert") of n $$\sqrt[n]{x}=\ x^{\frac{1}{n}}$$
- We can raise a value `x` to the power of a value `n` in R with the following code: `x^n`

To create a function that simplifies taking the n^th^ root, we just need one line of code:


```{r, echo = T, include = T, eval = T}
# specify two parameters:
# x: the value  with want to take the root from
# n: the root we want to take (2 for 2nd root)

nthroot <- function(x,n){x^(1/n)}

# Test function by taking the second root of 4. 
# Expecting the result to be 2:
nthroot(x = 4,n = 2)

```

As we already know from using other functions, if we declare our variables in the order that we initially listed them, we do not need to specify the parameters (no need of `x = `and `n = `).
```{r, echo = T, include = T, eval = T}
nthroot(27,3)
nthroot(3,3)
```


If we want any of our parameters to have default value, we can assign an initial value to the parameter when declaring the variables within the round brackets.
```{r, echo = T, include = T, eval = T}
nthroot <- function(x,n = 2){x^(1/n)}

# if not stated otherwise, our function takes the square root
nthroot(10)
# We can still overwrite n
nthroot(10,3)

```

All you need to do now is run these few lines of code at the beginning of your script, and you can use the function for your entire R session. After starting a new session, you will simply have to re-run the lines. So it might be a good idea to place this function within the section `Loading environment / libraries` of your project.

```{r}
#- chunkend
```


### Task 1: Write your own functions

Create a function for our Euclidean distance calculation. Optionally, write another function to number successive `TRUE` values with the `cumsum()` approach from last week. 

Note: if you treat your input variables as vectors, they will work in most use cases (in particular in `dplyr`s `mutate()` and `summarise()` functions). 


```{r}
#- header3 Task 1
#- chunkstart
```

```{r}
euclid <- function(x,y,leadval = 1){
  sqrt((x-lead(x,leadval))^2+(y-lead(y,leadval))^2)
}
```

```{r}
#- chunkend
```


### Task 2: Filter data

```{r}
#- header3 Task 2
#- chunkstart
```

We propose conceptualizing the pattern "meet" as "being close in space *and* time", with the notion "close" to be defined for the spatial and the temporal case separately. We will simplify the problem slightly so that we can use a number of R tools and data structures you now have learned to use by now. As a first simplification we propose manipulating the timestamps in such a way, that all observations are sampled concurrently, synchronously. This allows us using the data science concept *join* for detecting the temporal expression of meet - using `DateTimeUTC` as the key variable in a join statement: Observations with an identical time stamp will match. Once we have identified the temporal matches, we check if the concurrent observations are also close in space based on the Euclidean distances between concurrent positions.

Simplifying the task even further, we will focus on an interval where we have a continuous, small sampling interval over all our animals. So, filter your dataset to the time period 01.04.2015 - 15.04.2015) and save it to a new variable (e.g. `wildschwein_filter`). After filtering, visualize your data spatially. Just consider animals with a spatial overlap and remove animals where we cannot expect to find any meet patterns. 


```{r}
wildschwein_filter <- wildschwein_BE %>%
  filter(DatetimeUTC > "2015-04-01",
         DatetimeUTC < "2015-04-15") 
```


```{r, echo = T, include = T, eval = T}
wildschwein_filter %>%
  group_by(TierID) %>%
  summarise() %>%
  st_convex_hull() %>%
  ggplot() + geom_sf(aes(fill = TierID),alpha = 0.3)

wildschwein_filter <- wildschwein_filter %>%
  filter(TierID != "018A")

```

```{r}
#- chunkend
```

### Task 3: Create Join Key

```{r}
#- header3 Task 3
#- chunkstart
```




```{r, echo = T, include = T, eval = T}
head(wildschwein_filter)
```

Have a look at your dataset. You will notice that samples are taken at every full hour, quarter past, half past and quarter to. The sampling time is usually off by a couple of seconds. Verify if we have the same sampling interval (`timelag`) throughout our filtered dataset. 
```{r, echo = F, include = T, eval = T, fig.cap=""}
ggplot(wildschwein_filter, aes(DatetimeUTC,timelag/60, colour = TierID)) + 
  geom_line() + 
  geom_point()+ 
  expand_limits(y = 0) +
  facet_grid(TierID~.)
```


With a few exceptions, the sampling interval is *around* 15 minutes. In order to join the data, however, we need *identical* time stamps to serve as a join key. We therefore need to slightly adjust our time stamps to a common, concurrent interval. 

Round the minutes of `DatetimeUTC` to a multiple of 15 (00, 15, 30,45) and store the values in a new column. You can use the  `lubridate` function `round_date()` for this. See the examples [here](https://lubridate.tidyverse.org/reference/round_date.html) to see how this goes.

*Please note:* We are manipulating our time stamps without adjusting the x,y-coordinates. This is fine for our simple example, but we would advice against this in a more serious research endeavour, e.g. in your semester projects. One simple approach would be to linearly interpolate the positions to the new timestamps. If you choose Option A the wild boar projects as your semester projects, you should aim for a linear interpolation. Get in touch if you need help with this.


```{r, echo = F, include=T, eval = T, fig.cap="After resampling, the movement data is slightly manipulated (this visualization is not part of the task) since we changed the original timestamp. We are usually off from the 'true' value around 10 to 15 seconds, some are off by as much as 2 minutes. "}

wildschwein_filter <- wildschwein_filter %>%
  group_by(TierID) %>%
  mutate(
    DatetimeRound = round_date(DatetimeUTC,"15 minutes")
  )

wildschwein_filter %>%
  mutate(delta = abs(as.integer(difftime(DatetimeUTC,DatetimeRound, units = "secs")))) %>%
  ggplot(aes(delta)) +
  geom_histogram(binwidth = 1) +
  labs(x = "Absolute time difference between original- and rounded Timestamp",
       y = "Number of values")
```

```{r}
#- chunkend
```
### Task 4: Measuring distance at concurrent locations

```{r}
#- header3 Task 4
#- chunkstart
```

To measure the distance between concurrent locations, we need to follow the following steps.

1. First, split the `wildschwein_filter` object into one `data.frame` per animal.[^1]
2. Next, join these datasets by the new, manipulated `Datetime` column and save it to the variable `wildschwein_join`. Which join-type is appropriate? The joined observations are *temporally close*.
3. On `wildschwein_join`, calculate Euclidean distances between concurrent observations. Store the values in a new column `distance`. 
4. Use a reasonable threshold on `distance` to determine if the animals are also *spatially close* enough to constitute a *meet* (we use 50 meters). Store this Boolean information (`TRUE`/`FALSE`) in a new column named `meet`.

[^1]: This is a perfect opportunity to learn functional programming if you are an intermediate to advanced programmer (or want to be). You can use `purrr::map()` specifically for these tasks. Ask us if you want to learn this but are struggling


```{r}
wildschwein_join <- wildschwein_filter %>%
  ungroup() %>%
  select(TierID,DatetimeRound,E,N) %>%
  st_set_geometry(NULL) %>%
  split(.$TierID) %>%
  accumulate(~full_join(.x,.y, by = "DatetimeRound")) %>%
  pluck(length(.))


euclid2 <- function(x1,y1,x2,y2){
  sqrt((x1-x2)^2+(y2-y2)^2)
}


wildschwein_join <- wildschwein_join %>%
  mutate(
    distance = euclid2(E.x,N.x,E.y,N.y),
    meet = distance < 100
  )

```

```{r, echo = F, include=T, eval = T}
wildschwein_join
```



```{r}
#- chunkend
```
### Task 5: Visualize data

```{r}
#- header3 Task 5
#- chunkstart
```


Now, visualize the *meets* spatially. You can attempt to recreate the plot below, but this is not trivial. If you want to try it, these are the steps to take:

1. number the meet events with the `cumsum()` approach (saved as a column `meet_seq`)
2. use `gather`, `seperate()` and `spread()` (in that order) reshapingour wide `wildschwein_join` dataframe to long (with only single `E`/`N` columns)
3. turn the long table to `sf` with `st_as_sf()` and specifying our coordinate columns
4. Store steps 1 - 4 in a new variable (eg. `wildschwein_spread`)

Use this dataset to create circles at meet events. 

1. group by the `meet_seq`
2. Using `summarise()` to create multipoint features and extracting the start date and end time. 
3. `paste()` `meet_seq`, start date and end time into a new column (eg `name`)
4. use the function `st_minimum_bounding_circle()` from the library `liblwgeom` to create minimum bounding circles around each meet event.
5. Store these circles in a new variable (e.g. `meets`)

Add trajectories (`wildschwein_spread`) and the circles (`meets`) to gggplot and facet by `name`.

```{r, echo = F, include=T, eval = T, fig.height=12}

# library(ggpmisc)
# 
# pk25 <- brick("../CMA_FS2018_Filestorage/pk25.tif")
# swissimage <- brick("../CMA_FS2018_Filestorage/swissimage_250cm.tif")

number_seq = function(bool){
  fac <- as.factor(ifelse(bool,1+cumsum(!bool),NA))
  levels(fac) <- 1:length(levels(fac))
  return(fac)
}


library(lwgeom)

wildschwein_spread <- wildschwein_join %>%
  mutate(meet_seq = number_seq(meet)) %>% 
  gather(key,val, contains(".")) %>%
  separate(key,into = c("key","animal")) %>%
  spread(key,val,convert = T) %>%
  arrange(TierID,DatetimeRound) %>%
  st_as_sf(coords = c("E","N"),remove = F) %>%
  st_set_crs(2056) 

meets <- wildschwein_spread %>%
  filter(meet) %>%
  group_by(meet_seq) %>%
  summarise(
    start = min(DatetimeRound),
    end = max(DatetimeRound)
  ) %>%
  mutate(name = paste(meet_seq,":",start,"-",strftime(end,format = "%H:%M:%S"))) %>%
  st_minimum_bounding_circle()

ggplot(wildschwein_spread) +
  geom_point(aes(E,N,colour = TierID),alpha = 0.2) +
  geom_path(aes(E,N,colour = TierID),alpha = 0.2) +
  geom_sf(data = meets, alpha = 0.3, fill = "green") +
  facet_wrap(~name, ncol = 2) +
  coord_sf(datum = 2056) +
  theme_light() +
  theme(axis.title = element_blank()) +
  labs(title = paste("The",nrow(meets),"meet events of the two animals"), subtitle = "Using a threshold of 100 meters")



```

```{r}
#- chunkend
```


### Task 6 (optional): Visualize data as timecube with `plotly`

```{r}
#- header3 Task 6
#- chunkstart
```

Finally, you can nicely visualize the meeting patterns and trajectories in a Space-Time-Cube [@hagerstraand1970] with the package `plotly`. There are some [nice ressources](https://plot.ly/r/3d-line-plots/) available online.


```{r, echo = F, include=T, eval = knitr::is_html_output(), fig.cap="Trace 0 and 1 show the trajectories of the two individuals in 3D space, while time is the z-axis. The Dots represent instances where two animals are spatiotemporally close to each other. This representation nicely shows that animal '0' is not very mobile and has large periodes where the animal seems to rest in the same place."}

meanmeetpoints <- wildschwein_join %>%
  filter(meet) %>%
  mutate(
    E.mean = (E.x+E.y)/2,
    N.mean = (N.x+N.y)/2

  )

library(plotly)
plot_ly(wildschwein_join, x = ~E.x,y = ~N.x, z = ~DatetimeRound,type = "scatter3d", mode = "lines") %>%
  add_trace(wildschwein_join, x = ~E.y,y = ~N.y, z = ~DatetimeRound) %>%
  add_markers(data = meanmeetpoints, x = ~E.mean,y = ~N.mean, z = ~DatetimeRound) %>%
  layout(scene = list(xaxis = list(title = 'E'),
                      yaxis = list(title = 'N'),
                      zaxis = list(title = 'Time')))

```


```{r, echo = F, include=T, eval = knitr::is_html_output(), fig.cap="The same visualization as above, just with data filtered to the time of the meet events. In some instances, the events took place in stationary phases, indicating that the animlas might have interacted. In other events, the animlas simply seem to pass by each other, indicating that they might not have interacted."}
wildschwein_join %>%
  filter(DatetimeRound<"2015-04-04") %>%
  plot_ly(x = ~E.x,y = ~N.x, z = ~DatetimeRound,type = "scatter3d", mode = "lines") %>%
  add_trace(wildschwein_join, x = ~E.y,y = ~N.y, z = ~DatetimeRound) %>%
  add_markers(data = meanmeetpoints, x = ~E.mean,y = ~N.mean, z = ~DatetimeRound) %>%
  layout(scene = list(xaxis = list(title = 'E'),
                      yaxis = list(title = 'N'),
                      zaxis = list(title = 'Time')))
```



```{r, echo = F, include=T, eval = knitr::is_latex_output(), results = "asis", purl = F}
pander::pandoc.image("02_Images/batman-ipsum.png","The interactive map/plot is only available in the online version of this document.")
```





```{r}
#- chunkend
```





